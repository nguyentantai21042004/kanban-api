// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// RebalanceEvent is an object representing the database table.
type RebalanceEvent struct {
	ID              string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	ListID          null.String       `boil:"list_id" json:"list_id,omitempty" toml:"list_id" yaml:"list_id,omitempty"`
	BoardID         null.String       `boil:"board_id" json:"board_id,omitempty" toml:"board_id" yaml:"board_id,omitempty"`
	TargetType      string            `boil:"target_type" json:"target_type" toml:"target_type" yaml:"target_type"`
	Strategy        null.String       `boil:"strategy" json:"strategy,omitempty" toml:"strategy" yaml:"strategy,omitempty"`
	RecordCount     null.Int          `boil:"record_count" json:"record_count,omitempty" toml:"record_count" yaml:"record_count,omitempty"`
	AvgLengthBefore types.NullDecimal `boil:"avg_length_before" json:"avg_length_before,omitempty" toml:"avg_length_before" yaml:"avg_length_before,omitempty"`
	AvgLengthAfter  types.NullDecimal `boil:"avg_length_after" json:"avg_length_after,omitempty" toml:"avg_length_after" yaml:"avg_length_after,omitempty"`
	MaxLengthBefore null.Int          `boil:"max_length_before" json:"max_length_before,omitempty" toml:"max_length_before" yaml:"max_length_before,omitempty"`
	MaxLengthAfter  null.Int          `boil:"max_length_after" json:"max_length_after,omitempty" toml:"max_length_after" yaml:"max_length_after,omitempty"`
	MinLengthBefore null.Int          `boil:"min_length_before" json:"min_length_before,omitempty" toml:"min_length_before" yaml:"min_length_before,omitempty"`
	MinLengthAfter  null.Int          `boil:"min_length_after" json:"min_length_after,omitempty" toml:"min_length_after" yaml:"min_length_after,omitempty"`
	// Time taken to complete the rebalancing operation in milliseconds
	DurationMS    null.Int    `boil:"duration_ms" json:"duration_ms,omitempty" toml:"duration_ms" yaml:"duration_ms,omitempty"`
	TriggerReason null.String `boil:"trigger_reason" json:"trigger_reason,omitempty" toml:"trigger_reason" yaml:"trigger_reason,omitempty"`
	JobID         null.String `boil:"job_id" json:"job_id,omitempty" toml:"job_id" yaml:"job_id,omitempty"`
	CreatedAt     null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`

	R *rebalanceEventR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L rebalanceEventL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var RebalanceEventColumns = struct {
	ID              string
	ListID          string
	BoardID         string
	TargetType      string
	Strategy        string
	RecordCount     string
	AvgLengthBefore string
	AvgLengthAfter  string
	MaxLengthBefore string
	MaxLengthAfter  string
	MinLengthBefore string
	MinLengthAfter  string
	DurationMS      string
	TriggerReason   string
	JobID           string
	CreatedAt       string
}{
	ID:              "id",
	ListID:          "list_id",
	BoardID:         "board_id",
	TargetType:      "target_type",
	Strategy:        "strategy",
	RecordCount:     "record_count",
	AvgLengthBefore: "avg_length_before",
	AvgLengthAfter:  "avg_length_after",
	MaxLengthBefore: "max_length_before",
	MaxLengthAfter:  "max_length_after",
	MinLengthBefore: "min_length_before",
	MinLengthAfter:  "min_length_after",
	DurationMS:      "duration_ms",
	TriggerReason:   "trigger_reason",
	JobID:           "job_id",
	CreatedAt:       "created_at",
}

var RebalanceEventTableColumns = struct {
	ID              string
	ListID          string
	BoardID         string
	TargetType      string
	Strategy        string
	RecordCount     string
	AvgLengthBefore string
	AvgLengthAfter  string
	MaxLengthBefore string
	MaxLengthAfter  string
	MinLengthBefore string
	MinLengthAfter  string
	DurationMS      string
	TriggerReason   string
	JobID           string
	CreatedAt       string
}{
	ID:              "rebalance_events.id",
	ListID:          "rebalance_events.list_id",
	BoardID:         "rebalance_events.board_id",
	TargetType:      "rebalance_events.target_type",
	Strategy:        "rebalance_events.strategy",
	RecordCount:     "rebalance_events.record_count",
	AvgLengthBefore: "rebalance_events.avg_length_before",
	AvgLengthAfter:  "rebalance_events.avg_length_after",
	MaxLengthBefore: "rebalance_events.max_length_before",
	MaxLengthAfter:  "rebalance_events.max_length_after",
	MinLengthBefore: "rebalance_events.min_length_before",
	MinLengthAfter:  "rebalance_events.min_length_after",
	DurationMS:      "rebalance_events.duration_ms",
	TriggerReason:   "rebalance_events.trigger_reason",
	JobID:           "rebalance_events.job_id",
	CreatedAt:       "rebalance_events.created_at",
}

// Generated where

var RebalanceEventWhere = struct {
	ID              whereHelperstring
	ListID          whereHelpernull_String
	BoardID         whereHelpernull_String
	TargetType      whereHelperstring
	Strategy        whereHelpernull_String
	RecordCount     whereHelpernull_Int
	AvgLengthBefore whereHelpertypes_NullDecimal
	AvgLengthAfter  whereHelpertypes_NullDecimal
	MaxLengthBefore whereHelpernull_Int
	MaxLengthAfter  whereHelpernull_Int
	MinLengthBefore whereHelpernull_Int
	MinLengthAfter  whereHelpernull_Int
	DurationMS      whereHelpernull_Int
	TriggerReason   whereHelpernull_String
	JobID           whereHelpernull_String
	CreatedAt       whereHelpernull_Time
}{
	ID:              whereHelperstring{field: "\"rebalance_events\".\"id\""},
	ListID:          whereHelpernull_String{field: "\"rebalance_events\".\"list_id\""},
	BoardID:         whereHelpernull_String{field: "\"rebalance_events\".\"board_id\""},
	TargetType:      whereHelperstring{field: "\"rebalance_events\".\"target_type\""},
	Strategy:        whereHelpernull_String{field: "\"rebalance_events\".\"strategy\""},
	RecordCount:     whereHelpernull_Int{field: "\"rebalance_events\".\"record_count\""},
	AvgLengthBefore: whereHelpertypes_NullDecimal{field: "\"rebalance_events\".\"avg_length_before\""},
	AvgLengthAfter:  whereHelpertypes_NullDecimal{field: "\"rebalance_events\".\"avg_length_after\""},
	MaxLengthBefore: whereHelpernull_Int{field: "\"rebalance_events\".\"max_length_before\""},
	MaxLengthAfter:  whereHelpernull_Int{field: "\"rebalance_events\".\"max_length_after\""},
	MinLengthBefore: whereHelpernull_Int{field: "\"rebalance_events\".\"min_length_before\""},
	MinLengthAfter:  whereHelpernull_Int{field: "\"rebalance_events\".\"min_length_after\""},
	DurationMS:      whereHelpernull_Int{field: "\"rebalance_events\".\"duration_ms\""},
	TriggerReason:   whereHelpernull_String{field: "\"rebalance_events\".\"trigger_reason\""},
	JobID:           whereHelpernull_String{field: "\"rebalance_events\".\"job_id\""},
	CreatedAt:       whereHelpernull_Time{field: "\"rebalance_events\".\"created_at\""},
}

// RebalanceEventRels is where relationship names are stored.
var RebalanceEventRels = struct {
	Board string
	List  string
	Job   string
}{
	Board: "Board",
	List:  "List",
	Job:   "Job",
}

// rebalanceEventR is where relationships are stored.
type rebalanceEventR struct {
	Board *Board        `boil:"Board" json:"Board" toml:"Board" yaml:"Board"`
	List  *List         `boil:"List" json:"List" toml:"List" yaml:"List"`
	Job   *RebalanceJob `boil:"Job" json:"Job" toml:"Job" yaml:"Job"`
}

// NewStruct creates a new relationship struct
func (*rebalanceEventR) NewStruct() *rebalanceEventR {
	return &rebalanceEventR{}
}

func (o *RebalanceEvent) GetBoard() *Board {
	if o == nil {
		return nil
	}

	return o.R.GetBoard()
}

func (r *rebalanceEventR) GetBoard() *Board {
	if r == nil {
		return nil
	}

	return r.Board
}

func (o *RebalanceEvent) GetList() *List {
	if o == nil {
		return nil
	}

	return o.R.GetList()
}

func (r *rebalanceEventR) GetList() *List {
	if r == nil {
		return nil
	}

	return r.List
}

func (o *RebalanceEvent) GetJob() *RebalanceJob {
	if o == nil {
		return nil
	}

	return o.R.GetJob()
}

func (r *rebalanceEventR) GetJob() *RebalanceJob {
	if r == nil {
		return nil
	}

	return r.Job
}

// rebalanceEventL is where Load methods for each relationship are stored.
type rebalanceEventL struct{}

var (
	rebalanceEventAllColumns            = []string{"id", "list_id", "board_id", "target_type", "strategy", "record_count", "avg_length_before", "avg_length_after", "max_length_before", "max_length_after", "min_length_before", "min_length_after", "duration_ms", "trigger_reason", "job_id", "created_at"}
	rebalanceEventColumnsWithoutDefault = []string{}
	rebalanceEventColumnsWithDefault    = []string{"id", "list_id", "board_id", "target_type", "strategy", "record_count", "avg_length_before", "avg_length_after", "max_length_before", "max_length_after", "min_length_before", "min_length_after", "duration_ms", "trigger_reason", "job_id", "created_at"}
	rebalanceEventPrimaryKeyColumns     = []string{"id"}
	rebalanceEventGeneratedColumns      = []string{}
)

type (
	// RebalanceEventSlice is an alias for a slice of pointers to RebalanceEvent.
	// This should almost always be used instead of []RebalanceEvent.
	RebalanceEventSlice []*RebalanceEvent
	// RebalanceEventHook is the signature for custom RebalanceEvent hook methods
	RebalanceEventHook func(context.Context, boil.ContextExecutor, *RebalanceEvent) error

	rebalanceEventQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	rebalanceEventType                 = reflect.TypeOf(&RebalanceEvent{})
	rebalanceEventMapping              = queries.MakeStructMapping(rebalanceEventType)
	rebalanceEventPrimaryKeyMapping, _ = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, rebalanceEventPrimaryKeyColumns)
	rebalanceEventInsertCacheMut       sync.RWMutex
	rebalanceEventInsertCache          = make(map[string]insertCache)
	rebalanceEventUpdateCacheMut       sync.RWMutex
	rebalanceEventUpdateCache          = make(map[string]updateCache)
	rebalanceEventUpsertCacheMut       sync.RWMutex
	rebalanceEventUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var rebalanceEventAfterSelectMu sync.Mutex
var rebalanceEventAfterSelectHooks []RebalanceEventHook

var rebalanceEventBeforeInsertMu sync.Mutex
var rebalanceEventBeforeInsertHooks []RebalanceEventHook
var rebalanceEventAfterInsertMu sync.Mutex
var rebalanceEventAfterInsertHooks []RebalanceEventHook

var rebalanceEventBeforeUpdateMu sync.Mutex
var rebalanceEventBeforeUpdateHooks []RebalanceEventHook
var rebalanceEventAfterUpdateMu sync.Mutex
var rebalanceEventAfterUpdateHooks []RebalanceEventHook

var rebalanceEventBeforeDeleteMu sync.Mutex
var rebalanceEventBeforeDeleteHooks []RebalanceEventHook
var rebalanceEventAfterDeleteMu sync.Mutex
var rebalanceEventAfterDeleteHooks []RebalanceEventHook

var rebalanceEventBeforeUpsertMu sync.Mutex
var rebalanceEventBeforeUpsertHooks []RebalanceEventHook
var rebalanceEventAfterUpsertMu sync.Mutex
var rebalanceEventAfterUpsertHooks []RebalanceEventHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *RebalanceEvent) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *RebalanceEvent) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *RebalanceEvent) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *RebalanceEvent) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *RebalanceEvent) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *RebalanceEvent) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *RebalanceEvent) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *RebalanceEvent) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *RebalanceEvent) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceEventAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddRebalanceEventHook registers your hook function for all future operations.
func AddRebalanceEventHook(hookPoint boil.HookPoint, rebalanceEventHook RebalanceEventHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		rebalanceEventAfterSelectMu.Lock()
		rebalanceEventAfterSelectHooks = append(rebalanceEventAfterSelectHooks, rebalanceEventHook)
		rebalanceEventAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		rebalanceEventBeforeInsertMu.Lock()
		rebalanceEventBeforeInsertHooks = append(rebalanceEventBeforeInsertHooks, rebalanceEventHook)
		rebalanceEventBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		rebalanceEventAfterInsertMu.Lock()
		rebalanceEventAfterInsertHooks = append(rebalanceEventAfterInsertHooks, rebalanceEventHook)
		rebalanceEventAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		rebalanceEventBeforeUpdateMu.Lock()
		rebalanceEventBeforeUpdateHooks = append(rebalanceEventBeforeUpdateHooks, rebalanceEventHook)
		rebalanceEventBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		rebalanceEventAfterUpdateMu.Lock()
		rebalanceEventAfterUpdateHooks = append(rebalanceEventAfterUpdateHooks, rebalanceEventHook)
		rebalanceEventAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		rebalanceEventBeforeDeleteMu.Lock()
		rebalanceEventBeforeDeleteHooks = append(rebalanceEventBeforeDeleteHooks, rebalanceEventHook)
		rebalanceEventBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		rebalanceEventAfterDeleteMu.Lock()
		rebalanceEventAfterDeleteHooks = append(rebalanceEventAfterDeleteHooks, rebalanceEventHook)
		rebalanceEventAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		rebalanceEventBeforeUpsertMu.Lock()
		rebalanceEventBeforeUpsertHooks = append(rebalanceEventBeforeUpsertHooks, rebalanceEventHook)
		rebalanceEventBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		rebalanceEventAfterUpsertMu.Lock()
		rebalanceEventAfterUpsertHooks = append(rebalanceEventAfterUpsertHooks, rebalanceEventHook)
		rebalanceEventAfterUpsertMu.Unlock()
	}
}

// One returns a single rebalanceEvent record from the query.
func (q rebalanceEventQuery) One(ctx context.Context, exec boil.ContextExecutor) (*RebalanceEvent, error) {
	o := &RebalanceEvent{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for rebalance_events")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all RebalanceEvent records from the query.
func (q rebalanceEventQuery) All(ctx context.Context, exec boil.ContextExecutor) (RebalanceEventSlice, error) {
	var o []*RebalanceEvent

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to RebalanceEvent slice")
	}

	if len(rebalanceEventAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all RebalanceEvent records in the query.
func (q rebalanceEventQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count rebalance_events rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q rebalanceEventQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if rebalance_events exists")
	}

	return count > 0, nil
}

// Board pointed to by the foreign key.
func (o *RebalanceEvent) Board(mods ...qm.QueryMod) boardQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BoardID),
	}

	queryMods = append(queryMods, mods...)

	return Boards(queryMods...)
}

// List pointed to by the foreign key.
func (o *RebalanceEvent) List(mods ...qm.QueryMod) listQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ListID),
	}

	queryMods = append(queryMods, mods...)

	return Lists(queryMods...)
}

// Job pointed to by the foreign key.
func (o *RebalanceEvent) Job(mods ...qm.QueryMod) rebalanceJobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.JobID),
	}

	queryMods = append(queryMods, mods...)

	return RebalanceJobs(queryMods...)
}

// LoadBoard allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceEventL) LoadBoard(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceEvent interface{}, mods queries.Applicator) error {
	var slice []*RebalanceEvent
	var object *RebalanceEvent

	if singular {
		var ok bool
		object, ok = maybeRebalanceEvent.(*RebalanceEvent)
		if !ok {
			object = new(RebalanceEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceEvent))
			}
		}
	} else {
		s, ok := maybeRebalanceEvent.(*[]*RebalanceEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceEventR{}
		}
		if !queries.IsNil(object.BoardID) {
			args[object.BoardID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceEventR{}
			}

			if !queries.IsNil(obj.BoardID) {
				args[obj.BoardID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`boards`),
		qm.WhereIn(`boards.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`boards.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Board")
	}

	var resultSlice []*Board
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Board")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for boards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for boards")
	}

	if len(boardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Board = foreign
		if foreign.R == nil {
			foreign.R = &boardR{}
		}
		foreign.R.RebalanceEvents = append(foreign.R.RebalanceEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BoardID, foreign.ID) {
				local.R.Board = foreign
				if foreign.R == nil {
					foreign.R = &boardR{}
				}
				foreign.R.RebalanceEvents = append(foreign.R.RebalanceEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadList allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceEventL) LoadList(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceEvent interface{}, mods queries.Applicator) error {
	var slice []*RebalanceEvent
	var object *RebalanceEvent

	if singular {
		var ok bool
		object, ok = maybeRebalanceEvent.(*RebalanceEvent)
		if !ok {
			object = new(RebalanceEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceEvent))
			}
		}
	} else {
		s, ok := maybeRebalanceEvent.(*[]*RebalanceEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceEventR{}
		}
		if !queries.IsNil(object.ListID) {
			args[object.ListID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceEventR{}
			}

			if !queries.IsNil(obj.ListID) {
				args[obj.ListID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`lists`),
		qm.WhereIn(`lists.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`lists.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load List")
	}

	var resultSlice []*List
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice List")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for lists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lists")
	}

	if len(listAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.List = foreign
		if foreign.R == nil {
			foreign.R = &listR{}
		}
		foreign.R.RebalanceEvents = append(foreign.R.RebalanceEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ListID, foreign.ID) {
				local.R.List = foreign
				if foreign.R == nil {
					foreign.R = &listR{}
				}
				foreign.R.RebalanceEvents = append(foreign.R.RebalanceEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadJob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceEventL) LoadJob(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceEvent interface{}, mods queries.Applicator) error {
	var slice []*RebalanceEvent
	var object *RebalanceEvent

	if singular {
		var ok bool
		object, ok = maybeRebalanceEvent.(*RebalanceEvent)
		if !ok {
			object = new(RebalanceEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceEvent))
			}
		}
	} else {
		s, ok := maybeRebalanceEvent.(*[]*RebalanceEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceEventR{}
		}
		if !queries.IsNil(object.JobID) {
			args[object.JobID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceEventR{}
			}

			if !queries.IsNil(obj.JobID) {
				args[obj.JobID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`rebalance_jobs`),
		qm.WhereIn(`rebalance_jobs.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RebalanceJob")
	}

	var resultSlice []*RebalanceJob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RebalanceJob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for rebalance_jobs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for rebalance_jobs")
	}

	if len(rebalanceJobAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Job = foreign
		if foreign.R == nil {
			foreign.R = &rebalanceJobR{}
		}
		foreign.R.JobRebalanceEvents = append(foreign.R.JobRebalanceEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.JobID, foreign.ID) {
				local.R.Job = foreign
				if foreign.R == nil {
					foreign.R = &rebalanceJobR{}
				}
				foreign.R.JobRebalanceEvents = append(foreign.R.JobRebalanceEvents, local)
				break
			}
		}
	}

	return nil
}

// SetBoard of the rebalanceEvent to the related item.
// Sets o.R.Board to related.
// Adds o to related.R.RebalanceEvents.
func (o *RebalanceEvent) SetBoard(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Board) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"board_id"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BoardID, related.ID)
	if o.R == nil {
		o.R = &rebalanceEventR{
			Board: related,
		}
	} else {
		o.R.Board = related
	}

	if related.R == nil {
		related.R = &boardR{
			RebalanceEvents: RebalanceEventSlice{o},
		}
	} else {
		related.R.RebalanceEvents = append(related.R.RebalanceEvents, o)
	}

	return nil
}

// RemoveBoard relationship.
// Sets o.R.Board to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceEvent) RemoveBoard(ctx context.Context, exec boil.ContextExecutor, related *Board) error {
	var err error

	queries.SetScanner(&o.BoardID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("board_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Board = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RebalanceEvents {
		if queries.Equal(o.BoardID, ri.BoardID) {
			continue
		}

		ln := len(related.R.RebalanceEvents)
		if ln > 1 && i < ln-1 {
			related.R.RebalanceEvents[i] = related.R.RebalanceEvents[ln-1]
		}
		related.R.RebalanceEvents = related.R.RebalanceEvents[:ln-1]
		break
	}
	return nil
}

// SetList of the rebalanceEvent to the related item.
// Sets o.R.List to related.
// Adds o to related.R.RebalanceEvents.
func (o *RebalanceEvent) SetList(ctx context.Context, exec boil.ContextExecutor, insert bool, related *List) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"list_id"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ListID, related.ID)
	if o.R == nil {
		o.R = &rebalanceEventR{
			List: related,
		}
	} else {
		o.R.List = related
	}

	if related.R == nil {
		related.R = &listR{
			RebalanceEvents: RebalanceEventSlice{o},
		}
	} else {
		related.R.RebalanceEvents = append(related.R.RebalanceEvents, o)
	}

	return nil
}

// RemoveList relationship.
// Sets o.R.List to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceEvent) RemoveList(ctx context.Context, exec boil.ContextExecutor, related *List) error {
	var err error

	queries.SetScanner(&o.ListID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("list_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.List = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RebalanceEvents {
		if queries.Equal(o.ListID, ri.ListID) {
			continue
		}

		ln := len(related.R.RebalanceEvents)
		if ln > 1 && i < ln-1 {
			related.R.RebalanceEvents[i] = related.R.RebalanceEvents[ln-1]
		}
		related.R.RebalanceEvents = related.R.RebalanceEvents[:ln-1]
		break
	}
	return nil
}

// SetJob of the rebalanceEvent to the related item.
// Sets o.R.Job to related.
// Adds o to related.R.JobRebalanceEvents.
func (o *RebalanceEvent) SetJob(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RebalanceJob) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"job_id"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.JobID, related.ID)
	if o.R == nil {
		o.R = &rebalanceEventR{
			Job: related,
		}
	} else {
		o.R.Job = related
	}

	if related.R == nil {
		related.R = &rebalanceJobR{
			JobRebalanceEvents: RebalanceEventSlice{o},
		}
	} else {
		related.R.JobRebalanceEvents = append(related.R.JobRebalanceEvents, o)
	}

	return nil
}

// RemoveJob relationship.
// Sets o.R.Job to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceEvent) RemoveJob(ctx context.Context, exec boil.ContextExecutor, related *RebalanceJob) error {
	var err error

	queries.SetScanner(&o.JobID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("job_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Job = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.JobRebalanceEvents {
		if queries.Equal(o.JobID, ri.JobID) {
			continue
		}

		ln := len(related.R.JobRebalanceEvents)
		if ln > 1 && i < ln-1 {
			related.R.JobRebalanceEvents[i] = related.R.JobRebalanceEvents[ln-1]
		}
		related.R.JobRebalanceEvents = related.R.JobRebalanceEvents[:ln-1]
		break
	}
	return nil
}

// RebalanceEvents retrieves all the records using an executor.
func RebalanceEvents(mods ...qm.QueryMod) rebalanceEventQuery {
	mods = append(mods, qm.From("\"rebalance_events\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"rebalance_events\".*"})
	}

	return rebalanceEventQuery{q}
}

// FindRebalanceEvent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindRebalanceEvent(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*RebalanceEvent, error) {
	rebalanceEventObj := &RebalanceEvent{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"rebalance_events\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, rebalanceEventObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from rebalance_events")
	}

	if err = rebalanceEventObj.doAfterSelectHooks(ctx, exec); err != nil {
		return rebalanceEventObj, err
	}

	return rebalanceEventObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *RebalanceEvent) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no rebalance_events provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rebalanceEventColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	rebalanceEventInsertCacheMut.RLock()
	cache, cached := rebalanceEventInsertCache[key]
	rebalanceEventInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			rebalanceEventAllColumns,
			rebalanceEventColumnsWithDefault,
			rebalanceEventColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"rebalance_events\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"rebalance_events\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into rebalance_events")
	}

	if !cached {
		rebalanceEventInsertCacheMut.Lock()
		rebalanceEventInsertCache[key] = cache
		rebalanceEventInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the RebalanceEvent.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *RebalanceEvent) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	rebalanceEventUpdateCacheMut.RLock()
	cache, cached := rebalanceEventUpdateCache[key]
	rebalanceEventUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			rebalanceEventAllColumns,
			rebalanceEventPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update rebalance_events, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"rebalance_events\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, rebalanceEventPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, append(wl, rebalanceEventPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update rebalance_events row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for rebalance_events")
	}

	if !cached {
		rebalanceEventUpdateCacheMut.Lock()
		rebalanceEventUpdateCache[key] = cache
		rebalanceEventUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q rebalanceEventQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for rebalance_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for rebalance_events")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o RebalanceEventSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"rebalance_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, rebalanceEventPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in rebalanceEvent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all rebalanceEvent")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *RebalanceEvent) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no rebalance_events provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rebalanceEventColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	rebalanceEventUpsertCacheMut.RLock()
	cache, cached := rebalanceEventUpsertCache[key]
	rebalanceEventUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			rebalanceEventAllColumns,
			rebalanceEventColumnsWithDefault,
			rebalanceEventColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			rebalanceEventAllColumns,
			rebalanceEventPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert rebalance_events, could not build update column list")
		}

		ret := strmangle.SetComplement(rebalanceEventAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(rebalanceEventPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert rebalance_events, could not build conflict column list")
			}

			conflict = make([]string, len(rebalanceEventPrimaryKeyColumns))
			copy(conflict, rebalanceEventPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"rebalance_events\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(rebalanceEventType, rebalanceEventMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert rebalance_events")
	}

	if !cached {
		rebalanceEventUpsertCacheMut.Lock()
		rebalanceEventUpsertCache[key] = cache
		rebalanceEventUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single RebalanceEvent record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *RebalanceEvent) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no RebalanceEvent provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), rebalanceEventPrimaryKeyMapping)
	sql := "DELETE FROM \"rebalance_events\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from rebalance_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for rebalance_events")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q rebalanceEventQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no rebalanceEventQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from rebalance_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for rebalance_events")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o RebalanceEventSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(rebalanceEventBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"rebalance_events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, rebalanceEventPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from rebalanceEvent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for rebalance_events")
	}

	if len(rebalanceEventAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *RebalanceEvent) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindRebalanceEvent(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RebalanceEventSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := RebalanceEventSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"rebalance_events\".* FROM \"rebalance_events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, rebalanceEventPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in RebalanceEventSlice")
	}

	*o = slice

	return nil
}

// RebalanceEventExists checks if the RebalanceEvent row exists.
func RebalanceEventExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"rebalance_events\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if rebalance_events exists")
	}

	return exists, nil
}

// Exists checks if the RebalanceEvent row exists.
func (o *RebalanceEvent) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return RebalanceEventExists(ctx, exec, o.ID)
}
