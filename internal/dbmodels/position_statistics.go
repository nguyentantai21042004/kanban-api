// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// PositionStatistic is an object representing the database table.
type PositionStatistic struct {
	ID                string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	ListID            null.String       `boil:"list_id" json:"list_id,omitempty" toml:"list_id" yaml:"list_id,omitempty"`
	BoardID           null.String       `boil:"board_id" json:"board_id,omitempty" toml:"board_id" yaml:"board_id,omitempty"`
	TargetType        string            `boil:"target_type" json:"target_type" toml:"target_type" yaml:"target_type"`
	RecordCount       int               `boil:"record_count" json:"record_count" toml:"record_count" yaml:"record_count"`
	AvgLength         types.NullDecimal `boil:"avg_length" json:"avg_length,omitempty" toml:"avg_length" yaml:"avg_length,omitempty"`
	MaxLength         null.Int          `boil:"max_length" json:"max_length,omitempty" toml:"max_length" yaml:"max_length,omitempty"`
	MinLength         null.Int          `boil:"min_length" json:"min_length,omitempty" toml:"min_length" yaml:"min_length,omitempty"`
	LengthStddev      types.NullDecimal `boil:"length_stddev" json:"length_stddev,omitempty" toml:"length_stddev" yaml:"length_stddev,omitempty"`
	LongKeyCount      null.Int          `boil:"long_key_count" json:"long_key_count,omitempty" toml:"long_key_count" yaml:"long_key_count,omitempty"`
	LongKeyPercentage types.NullDecimal `boil:"long_key_percentage" json:"long_key_percentage,omitempty" toml:"long_key_percentage" yaml:"long_key_percentage,omitempty"`
	NeedsRebalance    null.Bool         `boil:"needs_rebalance" json:"needs_rebalance,omitempty" toml:"needs_rebalance" yaml:"needs_rebalance,omitempty"`
	// Position system health score (0-100)
	HealthScore types.NullDecimal `boil:"health_score" json:"health_score,omitempty" toml:"health_score" yaml:"health_score,omitempty"`
	// Estimated performance impact of current position distribution
	PerformanceImpact null.String `boil:"performance_impact" json:"performance_impact,omitempty" toml:"performance_impact" yaml:"performance_impact,omitempty"`
	CalculatedAt      null.Time   `boil:"calculated_at" json:"calculated_at,omitempty" toml:"calculated_at" yaml:"calculated_at,omitempty"`
	ExpiresAt         null.Time   `boil:"expires_at" json:"expires_at,omitempty" toml:"expires_at" yaml:"expires_at,omitempty"`

	R *positionStatisticR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L positionStatisticL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PositionStatisticColumns = struct {
	ID                string
	ListID            string
	BoardID           string
	TargetType        string
	RecordCount       string
	AvgLength         string
	MaxLength         string
	MinLength         string
	LengthStddev      string
	LongKeyCount      string
	LongKeyPercentage string
	NeedsRebalance    string
	HealthScore       string
	PerformanceImpact string
	CalculatedAt      string
	ExpiresAt         string
}{
	ID:                "id",
	ListID:            "list_id",
	BoardID:           "board_id",
	TargetType:        "target_type",
	RecordCount:       "record_count",
	AvgLength:         "avg_length",
	MaxLength:         "max_length",
	MinLength:         "min_length",
	LengthStddev:      "length_stddev",
	LongKeyCount:      "long_key_count",
	LongKeyPercentage: "long_key_percentage",
	NeedsRebalance:    "needs_rebalance",
	HealthScore:       "health_score",
	PerformanceImpact: "performance_impact",
	CalculatedAt:      "calculated_at",
	ExpiresAt:         "expires_at",
}

var PositionStatisticTableColumns = struct {
	ID                string
	ListID            string
	BoardID           string
	TargetType        string
	RecordCount       string
	AvgLength         string
	MaxLength         string
	MinLength         string
	LengthStddev      string
	LongKeyCount      string
	LongKeyPercentage string
	NeedsRebalance    string
	HealthScore       string
	PerformanceImpact string
	CalculatedAt      string
	ExpiresAt         string
}{
	ID:                "position_statistics.id",
	ListID:            "position_statistics.list_id",
	BoardID:           "position_statistics.board_id",
	TargetType:        "position_statistics.target_type",
	RecordCount:       "position_statistics.record_count",
	AvgLength:         "position_statistics.avg_length",
	MaxLength:         "position_statistics.max_length",
	MinLength:         "position_statistics.min_length",
	LengthStddev:      "position_statistics.length_stddev",
	LongKeyCount:      "position_statistics.long_key_count",
	LongKeyPercentage: "position_statistics.long_key_percentage",
	NeedsRebalance:    "position_statistics.needs_rebalance",
	HealthScore:       "position_statistics.health_score",
	PerformanceImpact: "position_statistics.performance_impact",
	CalculatedAt:      "position_statistics.calculated_at",
	ExpiresAt:         "position_statistics.expires_at",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var PositionStatisticWhere = struct {
	ID                whereHelperstring
	ListID            whereHelpernull_String
	BoardID           whereHelpernull_String
	TargetType        whereHelperstring
	RecordCount       whereHelperint
	AvgLength         whereHelpertypes_NullDecimal
	MaxLength         whereHelpernull_Int
	MinLength         whereHelpernull_Int
	LengthStddev      whereHelpertypes_NullDecimal
	LongKeyCount      whereHelpernull_Int
	LongKeyPercentage whereHelpertypes_NullDecimal
	NeedsRebalance    whereHelpernull_Bool
	HealthScore       whereHelpertypes_NullDecimal
	PerformanceImpact whereHelpernull_String
	CalculatedAt      whereHelpernull_Time
	ExpiresAt         whereHelpernull_Time
}{
	ID:                whereHelperstring{field: "\"position_statistics\".\"id\""},
	ListID:            whereHelpernull_String{field: "\"position_statistics\".\"list_id\""},
	BoardID:           whereHelpernull_String{field: "\"position_statistics\".\"board_id\""},
	TargetType:        whereHelperstring{field: "\"position_statistics\".\"target_type\""},
	RecordCount:       whereHelperint{field: "\"position_statistics\".\"record_count\""},
	AvgLength:         whereHelpertypes_NullDecimal{field: "\"position_statistics\".\"avg_length\""},
	MaxLength:         whereHelpernull_Int{field: "\"position_statistics\".\"max_length\""},
	MinLength:         whereHelpernull_Int{field: "\"position_statistics\".\"min_length\""},
	LengthStddev:      whereHelpertypes_NullDecimal{field: "\"position_statistics\".\"length_stddev\""},
	LongKeyCount:      whereHelpernull_Int{field: "\"position_statistics\".\"long_key_count\""},
	LongKeyPercentage: whereHelpertypes_NullDecimal{field: "\"position_statistics\".\"long_key_percentage\""},
	NeedsRebalance:    whereHelpernull_Bool{field: "\"position_statistics\".\"needs_rebalance\""},
	HealthScore:       whereHelpertypes_NullDecimal{field: "\"position_statistics\".\"health_score\""},
	PerformanceImpact: whereHelpernull_String{field: "\"position_statistics\".\"performance_impact\""},
	CalculatedAt:      whereHelpernull_Time{field: "\"position_statistics\".\"calculated_at\""},
	ExpiresAt:         whereHelpernull_Time{field: "\"position_statistics\".\"expires_at\""},
}

// PositionStatisticRels is where relationship names are stored.
var PositionStatisticRels = struct {
	Board string
	List  string
}{
	Board: "Board",
	List:  "List",
}

// positionStatisticR is where relationships are stored.
type positionStatisticR struct {
	Board *Board `boil:"Board" json:"Board" toml:"Board" yaml:"Board"`
	List  *List  `boil:"List" json:"List" toml:"List" yaml:"List"`
}

// NewStruct creates a new relationship struct
func (*positionStatisticR) NewStruct() *positionStatisticR {
	return &positionStatisticR{}
}

func (o *PositionStatistic) GetBoard() *Board {
	if o == nil {
		return nil
	}

	return o.R.GetBoard()
}

func (r *positionStatisticR) GetBoard() *Board {
	if r == nil {
		return nil
	}

	return r.Board
}

func (o *PositionStatistic) GetList() *List {
	if o == nil {
		return nil
	}

	return o.R.GetList()
}

func (r *positionStatisticR) GetList() *List {
	if r == nil {
		return nil
	}

	return r.List
}

// positionStatisticL is where Load methods for each relationship are stored.
type positionStatisticL struct{}

var (
	positionStatisticAllColumns            = []string{"id", "list_id", "board_id", "target_type", "record_count", "avg_length", "max_length", "min_length", "length_stddev", "long_key_count", "long_key_percentage", "needs_rebalance", "health_score", "performance_impact", "calculated_at", "expires_at"}
	positionStatisticColumnsWithoutDefault = []string{"record_count"}
	positionStatisticColumnsWithDefault    = []string{"id", "list_id", "board_id", "target_type", "avg_length", "max_length", "min_length", "length_stddev", "long_key_count", "long_key_percentage", "needs_rebalance", "health_score", "performance_impact", "calculated_at", "expires_at"}
	positionStatisticPrimaryKeyColumns     = []string{"id"}
	positionStatisticGeneratedColumns      = []string{}
)

type (
	// PositionStatisticSlice is an alias for a slice of pointers to PositionStatistic.
	// This should almost always be used instead of []PositionStatistic.
	PositionStatisticSlice []*PositionStatistic
	// PositionStatisticHook is the signature for custom PositionStatistic hook methods
	PositionStatisticHook func(context.Context, boil.ContextExecutor, *PositionStatistic) error

	positionStatisticQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	positionStatisticType                 = reflect.TypeOf(&PositionStatistic{})
	positionStatisticMapping              = queries.MakeStructMapping(positionStatisticType)
	positionStatisticPrimaryKeyMapping, _ = queries.BindMapping(positionStatisticType, positionStatisticMapping, positionStatisticPrimaryKeyColumns)
	positionStatisticInsertCacheMut       sync.RWMutex
	positionStatisticInsertCache          = make(map[string]insertCache)
	positionStatisticUpdateCacheMut       sync.RWMutex
	positionStatisticUpdateCache          = make(map[string]updateCache)
	positionStatisticUpsertCacheMut       sync.RWMutex
	positionStatisticUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var positionStatisticAfterSelectMu sync.Mutex
var positionStatisticAfterSelectHooks []PositionStatisticHook

var positionStatisticBeforeInsertMu sync.Mutex
var positionStatisticBeforeInsertHooks []PositionStatisticHook
var positionStatisticAfterInsertMu sync.Mutex
var positionStatisticAfterInsertHooks []PositionStatisticHook

var positionStatisticBeforeUpdateMu sync.Mutex
var positionStatisticBeforeUpdateHooks []PositionStatisticHook
var positionStatisticAfterUpdateMu sync.Mutex
var positionStatisticAfterUpdateHooks []PositionStatisticHook

var positionStatisticBeforeDeleteMu sync.Mutex
var positionStatisticBeforeDeleteHooks []PositionStatisticHook
var positionStatisticAfterDeleteMu sync.Mutex
var positionStatisticAfterDeleteHooks []PositionStatisticHook

var positionStatisticBeforeUpsertMu sync.Mutex
var positionStatisticBeforeUpsertHooks []PositionStatisticHook
var positionStatisticAfterUpsertMu sync.Mutex
var positionStatisticAfterUpsertHooks []PositionStatisticHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PositionStatistic) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PositionStatistic) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PositionStatistic) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PositionStatistic) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PositionStatistic) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PositionStatistic) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PositionStatistic) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PositionStatistic) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PositionStatistic) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range positionStatisticAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPositionStatisticHook registers your hook function for all future operations.
func AddPositionStatisticHook(hookPoint boil.HookPoint, positionStatisticHook PositionStatisticHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		positionStatisticAfterSelectMu.Lock()
		positionStatisticAfterSelectHooks = append(positionStatisticAfterSelectHooks, positionStatisticHook)
		positionStatisticAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		positionStatisticBeforeInsertMu.Lock()
		positionStatisticBeforeInsertHooks = append(positionStatisticBeforeInsertHooks, positionStatisticHook)
		positionStatisticBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		positionStatisticAfterInsertMu.Lock()
		positionStatisticAfterInsertHooks = append(positionStatisticAfterInsertHooks, positionStatisticHook)
		positionStatisticAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		positionStatisticBeforeUpdateMu.Lock()
		positionStatisticBeforeUpdateHooks = append(positionStatisticBeforeUpdateHooks, positionStatisticHook)
		positionStatisticBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		positionStatisticAfterUpdateMu.Lock()
		positionStatisticAfterUpdateHooks = append(positionStatisticAfterUpdateHooks, positionStatisticHook)
		positionStatisticAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		positionStatisticBeforeDeleteMu.Lock()
		positionStatisticBeforeDeleteHooks = append(positionStatisticBeforeDeleteHooks, positionStatisticHook)
		positionStatisticBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		positionStatisticAfterDeleteMu.Lock()
		positionStatisticAfterDeleteHooks = append(positionStatisticAfterDeleteHooks, positionStatisticHook)
		positionStatisticAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		positionStatisticBeforeUpsertMu.Lock()
		positionStatisticBeforeUpsertHooks = append(positionStatisticBeforeUpsertHooks, positionStatisticHook)
		positionStatisticBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		positionStatisticAfterUpsertMu.Lock()
		positionStatisticAfterUpsertHooks = append(positionStatisticAfterUpsertHooks, positionStatisticHook)
		positionStatisticAfterUpsertMu.Unlock()
	}
}

// One returns a single positionStatistic record from the query.
func (q positionStatisticQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PositionStatistic, error) {
	o := &PositionStatistic{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for position_statistics")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PositionStatistic records from the query.
func (q positionStatisticQuery) All(ctx context.Context, exec boil.ContextExecutor) (PositionStatisticSlice, error) {
	var o []*PositionStatistic

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to PositionStatistic slice")
	}

	if len(positionStatisticAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PositionStatistic records in the query.
func (q positionStatisticQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count position_statistics rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q positionStatisticQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if position_statistics exists")
	}

	return count > 0, nil
}

// Board pointed to by the foreign key.
func (o *PositionStatistic) Board(mods ...qm.QueryMod) boardQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BoardID),
	}

	queryMods = append(queryMods, mods...)

	return Boards(queryMods...)
}

// List pointed to by the foreign key.
func (o *PositionStatistic) List(mods ...qm.QueryMod) listQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ListID),
	}

	queryMods = append(queryMods, mods...)

	return Lists(queryMods...)
}

// LoadBoard allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (positionStatisticL) LoadBoard(ctx context.Context, e boil.ContextExecutor, singular bool, maybePositionStatistic interface{}, mods queries.Applicator) error {
	var slice []*PositionStatistic
	var object *PositionStatistic

	if singular {
		var ok bool
		object, ok = maybePositionStatistic.(*PositionStatistic)
		if !ok {
			object = new(PositionStatistic)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePositionStatistic)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePositionStatistic))
			}
		}
	} else {
		s, ok := maybePositionStatistic.(*[]*PositionStatistic)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePositionStatistic)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePositionStatistic))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &positionStatisticR{}
		}
		if !queries.IsNil(object.BoardID) {
			args[object.BoardID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &positionStatisticR{}
			}

			if !queries.IsNil(obj.BoardID) {
				args[obj.BoardID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`boards`),
		qm.WhereIn(`boards.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`boards.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Board")
	}

	var resultSlice []*Board
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Board")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for boards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for boards")
	}

	if len(boardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Board = foreign
		if foreign.R == nil {
			foreign.R = &boardR{}
		}
		foreign.R.PositionStatistics = append(foreign.R.PositionStatistics, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BoardID, foreign.ID) {
				local.R.Board = foreign
				if foreign.R == nil {
					foreign.R = &boardR{}
				}
				foreign.R.PositionStatistics = append(foreign.R.PositionStatistics, local)
				break
			}
		}
	}

	return nil
}

// LoadList allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (positionStatisticL) LoadList(ctx context.Context, e boil.ContextExecutor, singular bool, maybePositionStatistic interface{}, mods queries.Applicator) error {
	var slice []*PositionStatistic
	var object *PositionStatistic

	if singular {
		var ok bool
		object, ok = maybePositionStatistic.(*PositionStatistic)
		if !ok {
			object = new(PositionStatistic)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePositionStatistic)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePositionStatistic))
			}
		}
	} else {
		s, ok := maybePositionStatistic.(*[]*PositionStatistic)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePositionStatistic)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePositionStatistic))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &positionStatisticR{}
		}
		if !queries.IsNil(object.ListID) {
			args[object.ListID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &positionStatisticR{}
			}

			if !queries.IsNil(obj.ListID) {
				args[obj.ListID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`lists`),
		qm.WhereIn(`lists.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`lists.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load List")
	}

	var resultSlice []*List
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice List")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for lists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lists")
	}

	if len(listAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.List = foreign
		if foreign.R == nil {
			foreign.R = &listR{}
		}
		foreign.R.PositionStatistics = append(foreign.R.PositionStatistics, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ListID, foreign.ID) {
				local.R.List = foreign
				if foreign.R == nil {
					foreign.R = &listR{}
				}
				foreign.R.PositionStatistics = append(foreign.R.PositionStatistics, local)
				break
			}
		}
	}

	return nil
}

// SetBoard of the positionStatistic to the related item.
// Sets o.R.Board to related.
// Adds o to related.R.PositionStatistics.
func (o *PositionStatistic) SetBoard(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Board) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"position_statistics\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"board_id"}),
		strmangle.WhereClause("\"", "\"", 2, positionStatisticPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BoardID, related.ID)
	if o.R == nil {
		o.R = &positionStatisticR{
			Board: related,
		}
	} else {
		o.R.Board = related
	}

	if related.R == nil {
		related.R = &boardR{
			PositionStatistics: PositionStatisticSlice{o},
		}
	} else {
		related.R.PositionStatistics = append(related.R.PositionStatistics, o)
	}

	return nil
}

// RemoveBoard relationship.
// Sets o.R.Board to nil.
// Removes o from all passed in related items' relationships struct.
func (o *PositionStatistic) RemoveBoard(ctx context.Context, exec boil.ContextExecutor, related *Board) error {
	var err error

	queries.SetScanner(&o.BoardID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("board_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Board = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PositionStatistics {
		if queries.Equal(o.BoardID, ri.BoardID) {
			continue
		}

		ln := len(related.R.PositionStatistics)
		if ln > 1 && i < ln-1 {
			related.R.PositionStatistics[i] = related.R.PositionStatistics[ln-1]
		}
		related.R.PositionStatistics = related.R.PositionStatistics[:ln-1]
		break
	}
	return nil
}

// SetList of the positionStatistic to the related item.
// Sets o.R.List to related.
// Adds o to related.R.PositionStatistics.
func (o *PositionStatistic) SetList(ctx context.Context, exec boil.ContextExecutor, insert bool, related *List) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"position_statistics\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"list_id"}),
		strmangle.WhereClause("\"", "\"", 2, positionStatisticPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ListID, related.ID)
	if o.R == nil {
		o.R = &positionStatisticR{
			List: related,
		}
	} else {
		o.R.List = related
	}

	if related.R == nil {
		related.R = &listR{
			PositionStatistics: PositionStatisticSlice{o},
		}
	} else {
		related.R.PositionStatistics = append(related.R.PositionStatistics, o)
	}

	return nil
}

// RemoveList relationship.
// Sets o.R.List to nil.
// Removes o from all passed in related items' relationships struct.
func (o *PositionStatistic) RemoveList(ctx context.Context, exec boil.ContextExecutor, related *List) error {
	var err error

	queries.SetScanner(&o.ListID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("list_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.List = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PositionStatistics {
		if queries.Equal(o.ListID, ri.ListID) {
			continue
		}

		ln := len(related.R.PositionStatistics)
		if ln > 1 && i < ln-1 {
			related.R.PositionStatistics[i] = related.R.PositionStatistics[ln-1]
		}
		related.R.PositionStatistics = related.R.PositionStatistics[:ln-1]
		break
	}
	return nil
}

// PositionStatistics retrieves all the records using an executor.
func PositionStatistics(mods ...qm.QueryMod) positionStatisticQuery {
	mods = append(mods, qm.From("\"position_statistics\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"position_statistics\".*"})
	}

	return positionStatisticQuery{q}
}

// FindPositionStatistic retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPositionStatistic(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*PositionStatistic, error) {
	positionStatisticObj := &PositionStatistic{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"position_statistics\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, positionStatisticObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from position_statistics")
	}

	if err = positionStatisticObj.doAfterSelectHooks(ctx, exec); err != nil {
		return positionStatisticObj, err
	}

	return positionStatisticObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PositionStatistic) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no position_statistics provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(positionStatisticColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	positionStatisticInsertCacheMut.RLock()
	cache, cached := positionStatisticInsertCache[key]
	positionStatisticInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			positionStatisticAllColumns,
			positionStatisticColumnsWithDefault,
			positionStatisticColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(positionStatisticType, positionStatisticMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(positionStatisticType, positionStatisticMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"position_statistics\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"position_statistics\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into position_statistics")
	}

	if !cached {
		positionStatisticInsertCacheMut.Lock()
		positionStatisticInsertCache[key] = cache
		positionStatisticInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the PositionStatistic.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PositionStatistic) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	positionStatisticUpdateCacheMut.RLock()
	cache, cached := positionStatisticUpdateCache[key]
	positionStatisticUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			positionStatisticAllColumns,
			positionStatisticPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update position_statistics, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"position_statistics\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, positionStatisticPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(positionStatisticType, positionStatisticMapping, append(wl, positionStatisticPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update position_statistics row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for position_statistics")
	}

	if !cached {
		positionStatisticUpdateCacheMut.Lock()
		positionStatisticUpdateCache[key] = cache
		positionStatisticUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q positionStatisticQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for position_statistics")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for position_statistics")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PositionStatisticSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), positionStatisticPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"position_statistics\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, positionStatisticPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in positionStatistic slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all positionStatistic")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PositionStatistic) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no position_statistics provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(positionStatisticColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	positionStatisticUpsertCacheMut.RLock()
	cache, cached := positionStatisticUpsertCache[key]
	positionStatisticUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			positionStatisticAllColumns,
			positionStatisticColumnsWithDefault,
			positionStatisticColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			positionStatisticAllColumns,
			positionStatisticPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert position_statistics, could not build update column list")
		}

		ret := strmangle.SetComplement(positionStatisticAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(positionStatisticPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert position_statistics, could not build conflict column list")
			}

			conflict = make([]string, len(positionStatisticPrimaryKeyColumns))
			copy(conflict, positionStatisticPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"position_statistics\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(positionStatisticType, positionStatisticMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(positionStatisticType, positionStatisticMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert position_statistics")
	}

	if !cached {
		positionStatisticUpsertCacheMut.Lock()
		positionStatisticUpsertCache[key] = cache
		positionStatisticUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single PositionStatistic record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PositionStatistic) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no PositionStatistic provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), positionStatisticPrimaryKeyMapping)
	sql := "DELETE FROM \"position_statistics\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from position_statistics")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for position_statistics")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q positionStatisticQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no positionStatisticQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from position_statistics")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for position_statistics")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PositionStatisticSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(positionStatisticBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), positionStatisticPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"position_statistics\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, positionStatisticPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from positionStatistic slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for position_statistics")
	}

	if len(positionStatisticAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PositionStatistic) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPositionStatistic(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PositionStatisticSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PositionStatisticSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), positionStatisticPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"position_statistics\".* FROM \"position_statistics\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, positionStatisticPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in PositionStatisticSlice")
	}

	*o = slice

	return nil
}

// PositionStatisticExists checks if the PositionStatistic row exists.
func PositionStatisticExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"position_statistics\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if position_statistics exists")
	}

	return exists, nil
}

// Exists checks if the PositionStatistic row exists.
func (o *PositionStatistic) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return PositionStatisticExists(ctx, exec, o.ID)
}
