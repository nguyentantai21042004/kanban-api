// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// RebalanceJob is an object representing the database table.
type RebalanceJob struct {
	ID      string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	ListID  null.String `boil:"list_id" json:"list_id,omitempty" toml:"list_id" yaml:"list_id,omitempty"`
	BoardID null.String `boil:"board_id" json:"board_id,omitempty" toml:"board_id" yaml:"board_id,omitempty"`
	// Type of entity to rebalance: cards or lists
	TargetType string `boil:"target_type" json:"target_type" toml:"target_type" yaml:"target_type"`
	// Job priority: critical, high, normal, low, background
	Priority null.String `boil:"priority" json:"priority,omitempty" toml:"priority" yaml:"priority,omitempty"`
	Status   null.String `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	// What triggered this rebalancing job
	TriggerReason null.String `boil:"trigger_reason" json:"trigger_reason,omitempty" toml:"trigger_reason" yaml:"trigger_reason,omitempty"`
	// Rebalancing strategy: conservative or aggressive
	Strategy     null.String `boil:"strategy" json:"strategy,omitempty" toml:"strategy" yaml:"strategy,omitempty"`
	ScheduledAt  null.Time   `boil:"scheduled_at" json:"scheduled_at,omitempty" toml:"scheduled_at" yaml:"scheduled_at,omitempty"`
	StartedAt    null.Time   `boil:"started_at" json:"started_at,omitempty" toml:"started_at" yaml:"started_at,omitempty"`
	CompletedAt  null.Time   `boil:"completed_at" json:"completed_at,omitempty" toml:"completed_at" yaml:"completed_at,omitempty"`
	ErrorMessage null.String `boil:"error_message" json:"error_message,omitempty" toml:"error_message" yaml:"error_message,omitempty"`
	Result       null.JSON   `boil:"result" json:"result,omitempty" toml:"result" yaml:"result,omitempty"`
	Attempts     null.Int    `boil:"attempts" json:"attempts,omitempty" toml:"attempts" yaml:"attempts,omitempty"`
	MaxAttempts  null.Int    `boil:"max_attempts" json:"max_attempts,omitempty" toml:"max_attempts" yaml:"max_attempts,omitempty"`
	CreatedAt    null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	CreatedBy    null.String `boil:"created_by" json:"created_by,omitempty" toml:"created_by" yaml:"created_by,omitempty"`

	R *rebalanceJobR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L rebalanceJobL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var RebalanceJobColumns = struct {
	ID            string
	ListID        string
	BoardID       string
	TargetType    string
	Priority      string
	Status        string
	TriggerReason string
	Strategy      string
	ScheduledAt   string
	StartedAt     string
	CompletedAt   string
	ErrorMessage  string
	Result        string
	Attempts      string
	MaxAttempts   string
	CreatedAt     string
	CreatedBy     string
}{
	ID:            "id",
	ListID:        "list_id",
	BoardID:       "board_id",
	TargetType:    "target_type",
	Priority:      "priority",
	Status:        "status",
	TriggerReason: "trigger_reason",
	Strategy:      "strategy",
	ScheduledAt:   "scheduled_at",
	StartedAt:     "started_at",
	CompletedAt:   "completed_at",
	ErrorMessage:  "error_message",
	Result:        "result",
	Attempts:      "attempts",
	MaxAttempts:   "max_attempts",
	CreatedAt:     "created_at",
	CreatedBy:     "created_by",
}

var RebalanceJobTableColumns = struct {
	ID            string
	ListID        string
	BoardID       string
	TargetType    string
	Priority      string
	Status        string
	TriggerReason string
	Strategy      string
	ScheduledAt   string
	StartedAt     string
	CompletedAt   string
	ErrorMessage  string
	Result        string
	Attempts      string
	MaxAttempts   string
	CreatedAt     string
	CreatedBy     string
}{
	ID:            "rebalance_jobs.id",
	ListID:        "rebalance_jobs.list_id",
	BoardID:       "rebalance_jobs.board_id",
	TargetType:    "rebalance_jobs.target_type",
	Priority:      "rebalance_jobs.priority",
	Status:        "rebalance_jobs.status",
	TriggerReason: "rebalance_jobs.trigger_reason",
	Strategy:      "rebalance_jobs.strategy",
	ScheduledAt:   "rebalance_jobs.scheduled_at",
	StartedAt:     "rebalance_jobs.started_at",
	CompletedAt:   "rebalance_jobs.completed_at",
	ErrorMessage:  "rebalance_jobs.error_message",
	Result:        "rebalance_jobs.result",
	Attempts:      "rebalance_jobs.attempts",
	MaxAttempts:   "rebalance_jobs.max_attempts",
	CreatedAt:     "rebalance_jobs.created_at",
	CreatedBy:     "rebalance_jobs.created_by",
}

// Generated where

var RebalanceJobWhere = struct {
	ID            whereHelperstring
	ListID        whereHelpernull_String
	BoardID       whereHelpernull_String
	TargetType    whereHelperstring
	Priority      whereHelpernull_String
	Status        whereHelpernull_String
	TriggerReason whereHelpernull_String
	Strategy      whereHelpernull_String
	ScheduledAt   whereHelpernull_Time
	StartedAt     whereHelpernull_Time
	CompletedAt   whereHelpernull_Time
	ErrorMessage  whereHelpernull_String
	Result        whereHelpernull_JSON
	Attempts      whereHelpernull_Int
	MaxAttempts   whereHelpernull_Int
	CreatedAt     whereHelpernull_Time
	CreatedBy     whereHelpernull_String
}{
	ID:            whereHelperstring{field: "\"rebalance_jobs\".\"id\""},
	ListID:        whereHelpernull_String{field: "\"rebalance_jobs\".\"list_id\""},
	BoardID:       whereHelpernull_String{field: "\"rebalance_jobs\".\"board_id\""},
	TargetType:    whereHelperstring{field: "\"rebalance_jobs\".\"target_type\""},
	Priority:      whereHelpernull_String{field: "\"rebalance_jobs\".\"priority\""},
	Status:        whereHelpernull_String{field: "\"rebalance_jobs\".\"status\""},
	TriggerReason: whereHelpernull_String{field: "\"rebalance_jobs\".\"trigger_reason\""},
	Strategy:      whereHelpernull_String{field: "\"rebalance_jobs\".\"strategy\""},
	ScheduledAt:   whereHelpernull_Time{field: "\"rebalance_jobs\".\"scheduled_at\""},
	StartedAt:     whereHelpernull_Time{field: "\"rebalance_jobs\".\"started_at\""},
	CompletedAt:   whereHelpernull_Time{field: "\"rebalance_jobs\".\"completed_at\""},
	ErrorMessage:  whereHelpernull_String{field: "\"rebalance_jobs\".\"error_message\""},
	Result:        whereHelpernull_JSON{field: "\"rebalance_jobs\".\"result\""},
	Attempts:      whereHelpernull_Int{field: "\"rebalance_jobs\".\"attempts\""},
	MaxAttempts:   whereHelpernull_Int{field: "\"rebalance_jobs\".\"max_attempts\""},
	CreatedAt:     whereHelpernull_Time{field: "\"rebalance_jobs\".\"created_at\""},
	CreatedBy:     whereHelpernull_String{field: "\"rebalance_jobs\".\"created_by\""},
}

// RebalanceJobRels is where relationship names are stored.
var RebalanceJobRels = struct {
	Board              string
	List               string
	CreatedByUser      string
	JobRebalanceEvents string
}{
	Board:              "Board",
	List:               "List",
	CreatedByUser:      "CreatedByUser",
	JobRebalanceEvents: "JobRebalanceEvents",
}

// rebalanceJobR is where relationships are stored.
type rebalanceJobR struct {
	Board              *Board              `boil:"Board" json:"Board" toml:"Board" yaml:"Board"`
	List               *List               `boil:"List" json:"List" toml:"List" yaml:"List"`
	CreatedByUser      *User               `boil:"CreatedByUser" json:"CreatedByUser" toml:"CreatedByUser" yaml:"CreatedByUser"`
	JobRebalanceEvents RebalanceEventSlice `boil:"JobRebalanceEvents" json:"JobRebalanceEvents" toml:"JobRebalanceEvents" yaml:"JobRebalanceEvents"`
}

// NewStruct creates a new relationship struct
func (*rebalanceJobR) NewStruct() *rebalanceJobR {
	return &rebalanceJobR{}
}

func (o *RebalanceJob) GetBoard() *Board {
	if o == nil {
		return nil
	}

	return o.R.GetBoard()
}

func (r *rebalanceJobR) GetBoard() *Board {
	if r == nil {
		return nil
	}

	return r.Board
}

func (o *RebalanceJob) GetList() *List {
	if o == nil {
		return nil
	}

	return o.R.GetList()
}

func (r *rebalanceJobR) GetList() *List {
	if r == nil {
		return nil
	}

	return r.List
}

func (o *RebalanceJob) GetCreatedByUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByUser()
}

func (r *rebalanceJobR) GetCreatedByUser() *User {
	if r == nil {
		return nil
	}

	return r.CreatedByUser
}

func (o *RebalanceJob) GetJobRebalanceEvents() RebalanceEventSlice {
	if o == nil {
		return nil
	}

	return o.R.GetJobRebalanceEvents()
}

func (r *rebalanceJobR) GetJobRebalanceEvents() RebalanceEventSlice {
	if r == nil {
		return nil
	}

	return r.JobRebalanceEvents
}

// rebalanceJobL is where Load methods for each relationship are stored.
type rebalanceJobL struct{}

var (
	rebalanceJobAllColumns            = []string{"id", "list_id", "board_id", "target_type", "priority", "status", "trigger_reason", "strategy", "scheduled_at", "started_at", "completed_at", "error_message", "result", "attempts", "max_attempts", "created_at", "created_by"}
	rebalanceJobColumnsWithoutDefault = []string{}
	rebalanceJobColumnsWithDefault    = []string{"id", "list_id", "board_id", "target_type", "priority", "status", "trigger_reason", "strategy", "scheduled_at", "started_at", "completed_at", "error_message", "result", "attempts", "max_attempts", "created_at", "created_by"}
	rebalanceJobPrimaryKeyColumns     = []string{"id"}
	rebalanceJobGeneratedColumns      = []string{}
)

type (
	// RebalanceJobSlice is an alias for a slice of pointers to RebalanceJob.
	// This should almost always be used instead of []RebalanceJob.
	RebalanceJobSlice []*RebalanceJob
	// RebalanceJobHook is the signature for custom RebalanceJob hook methods
	RebalanceJobHook func(context.Context, boil.ContextExecutor, *RebalanceJob) error

	rebalanceJobQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	rebalanceJobType                 = reflect.TypeOf(&RebalanceJob{})
	rebalanceJobMapping              = queries.MakeStructMapping(rebalanceJobType)
	rebalanceJobPrimaryKeyMapping, _ = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, rebalanceJobPrimaryKeyColumns)
	rebalanceJobInsertCacheMut       sync.RWMutex
	rebalanceJobInsertCache          = make(map[string]insertCache)
	rebalanceJobUpdateCacheMut       sync.RWMutex
	rebalanceJobUpdateCache          = make(map[string]updateCache)
	rebalanceJobUpsertCacheMut       sync.RWMutex
	rebalanceJobUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var rebalanceJobAfterSelectMu sync.Mutex
var rebalanceJobAfterSelectHooks []RebalanceJobHook

var rebalanceJobBeforeInsertMu sync.Mutex
var rebalanceJobBeforeInsertHooks []RebalanceJobHook
var rebalanceJobAfterInsertMu sync.Mutex
var rebalanceJobAfterInsertHooks []RebalanceJobHook

var rebalanceJobBeforeUpdateMu sync.Mutex
var rebalanceJobBeforeUpdateHooks []RebalanceJobHook
var rebalanceJobAfterUpdateMu sync.Mutex
var rebalanceJobAfterUpdateHooks []RebalanceJobHook

var rebalanceJobBeforeDeleteMu sync.Mutex
var rebalanceJobBeforeDeleteHooks []RebalanceJobHook
var rebalanceJobAfterDeleteMu sync.Mutex
var rebalanceJobAfterDeleteHooks []RebalanceJobHook

var rebalanceJobBeforeUpsertMu sync.Mutex
var rebalanceJobBeforeUpsertHooks []RebalanceJobHook
var rebalanceJobAfterUpsertMu sync.Mutex
var rebalanceJobAfterUpsertHooks []RebalanceJobHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *RebalanceJob) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *RebalanceJob) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *RebalanceJob) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *RebalanceJob) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *RebalanceJob) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *RebalanceJob) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *RebalanceJob) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *RebalanceJob) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *RebalanceJob) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rebalanceJobAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddRebalanceJobHook registers your hook function for all future operations.
func AddRebalanceJobHook(hookPoint boil.HookPoint, rebalanceJobHook RebalanceJobHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		rebalanceJobAfterSelectMu.Lock()
		rebalanceJobAfterSelectHooks = append(rebalanceJobAfterSelectHooks, rebalanceJobHook)
		rebalanceJobAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		rebalanceJobBeforeInsertMu.Lock()
		rebalanceJobBeforeInsertHooks = append(rebalanceJobBeforeInsertHooks, rebalanceJobHook)
		rebalanceJobBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		rebalanceJobAfterInsertMu.Lock()
		rebalanceJobAfterInsertHooks = append(rebalanceJobAfterInsertHooks, rebalanceJobHook)
		rebalanceJobAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		rebalanceJobBeforeUpdateMu.Lock()
		rebalanceJobBeforeUpdateHooks = append(rebalanceJobBeforeUpdateHooks, rebalanceJobHook)
		rebalanceJobBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		rebalanceJobAfterUpdateMu.Lock()
		rebalanceJobAfterUpdateHooks = append(rebalanceJobAfterUpdateHooks, rebalanceJobHook)
		rebalanceJobAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		rebalanceJobBeforeDeleteMu.Lock()
		rebalanceJobBeforeDeleteHooks = append(rebalanceJobBeforeDeleteHooks, rebalanceJobHook)
		rebalanceJobBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		rebalanceJobAfterDeleteMu.Lock()
		rebalanceJobAfterDeleteHooks = append(rebalanceJobAfterDeleteHooks, rebalanceJobHook)
		rebalanceJobAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		rebalanceJobBeforeUpsertMu.Lock()
		rebalanceJobBeforeUpsertHooks = append(rebalanceJobBeforeUpsertHooks, rebalanceJobHook)
		rebalanceJobBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		rebalanceJobAfterUpsertMu.Lock()
		rebalanceJobAfterUpsertHooks = append(rebalanceJobAfterUpsertHooks, rebalanceJobHook)
		rebalanceJobAfterUpsertMu.Unlock()
	}
}

// One returns a single rebalanceJob record from the query.
func (q rebalanceJobQuery) One(ctx context.Context, exec boil.ContextExecutor) (*RebalanceJob, error) {
	o := &RebalanceJob{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for rebalance_jobs")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all RebalanceJob records from the query.
func (q rebalanceJobQuery) All(ctx context.Context, exec boil.ContextExecutor) (RebalanceJobSlice, error) {
	var o []*RebalanceJob

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to RebalanceJob slice")
	}

	if len(rebalanceJobAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all RebalanceJob records in the query.
func (q rebalanceJobQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count rebalance_jobs rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q rebalanceJobQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if rebalance_jobs exists")
	}

	return count > 0, nil
}

// Board pointed to by the foreign key.
func (o *RebalanceJob) Board(mods ...qm.QueryMod) boardQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BoardID),
	}

	queryMods = append(queryMods, mods...)

	return Boards(queryMods...)
}

// List pointed to by the foreign key.
func (o *RebalanceJob) List(mods ...qm.QueryMod) listQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ListID),
	}

	queryMods = append(queryMods, mods...)

	return Lists(queryMods...)
}

// CreatedByUser pointed to by the foreign key.
func (o *RebalanceJob) CreatedByUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedBy),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// JobRebalanceEvents retrieves all the rebalance_event's RebalanceEvents with an executor via job_id column.
func (o *RebalanceJob) JobRebalanceEvents(mods ...qm.QueryMod) rebalanceEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"rebalance_events\".\"job_id\"=?", o.ID),
	)

	return RebalanceEvents(queryMods...)
}

// LoadBoard allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceJobL) LoadBoard(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceJob interface{}, mods queries.Applicator) error {
	var slice []*RebalanceJob
	var object *RebalanceJob

	if singular {
		var ok bool
		object, ok = maybeRebalanceJob.(*RebalanceJob)
		if !ok {
			object = new(RebalanceJob)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceJob))
			}
		}
	} else {
		s, ok := maybeRebalanceJob.(*[]*RebalanceJob)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceJob))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceJobR{}
		}
		if !queries.IsNil(object.BoardID) {
			args[object.BoardID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceJobR{}
			}

			if !queries.IsNil(obj.BoardID) {
				args[obj.BoardID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`boards`),
		qm.WhereIn(`boards.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`boards.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Board")
	}

	var resultSlice []*Board
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Board")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for boards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for boards")
	}

	if len(boardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Board = foreign
		if foreign.R == nil {
			foreign.R = &boardR{}
		}
		foreign.R.RebalanceJobs = append(foreign.R.RebalanceJobs, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BoardID, foreign.ID) {
				local.R.Board = foreign
				if foreign.R == nil {
					foreign.R = &boardR{}
				}
				foreign.R.RebalanceJobs = append(foreign.R.RebalanceJobs, local)
				break
			}
		}
	}

	return nil
}

// LoadList allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceJobL) LoadList(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceJob interface{}, mods queries.Applicator) error {
	var slice []*RebalanceJob
	var object *RebalanceJob

	if singular {
		var ok bool
		object, ok = maybeRebalanceJob.(*RebalanceJob)
		if !ok {
			object = new(RebalanceJob)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceJob))
			}
		}
	} else {
		s, ok := maybeRebalanceJob.(*[]*RebalanceJob)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceJob))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceJobR{}
		}
		if !queries.IsNil(object.ListID) {
			args[object.ListID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceJobR{}
			}

			if !queries.IsNil(obj.ListID) {
				args[obj.ListID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`lists`),
		qm.WhereIn(`lists.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`lists.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load List")
	}

	var resultSlice []*List
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice List")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for lists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lists")
	}

	if len(listAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.List = foreign
		if foreign.R == nil {
			foreign.R = &listR{}
		}
		foreign.R.RebalanceJobs = append(foreign.R.RebalanceJobs, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ListID, foreign.ID) {
				local.R.List = foreign
				if foreign.R == nil {
					foreign.R = &listR{}
				}
				foreign.R.RebalanceJobs = append(foreign.R.RebalanceJobs, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedByUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (rebalanceJobL) LoadCreatedByUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceJob interface{}, mods queries.Applicator) error {
	var slice []*RebalanceJob
	var object *RebalanceJob

	if singular {
		var ok bool
		object, ok = maybeRebalanceJob.(*RebalanceJob)
		if !ok {
			object = new(RebalanceJob)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceJob))
			}
		}
	} else {
		s, ok := maybeRebalanceJob.(*[]*RebalanceJob)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceJob))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceJobR{}
		}
		if !queries.IsNil(object.CreatedBy) {
			args[object.CreatedBy] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceJobR{}
			}

			if !queries.IsNil(obj.CreatedBy) {
				args[obj.CreatedBy] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`users.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedByUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByRebalanceJobs = append(foreign.R.CreatedByRebalanceJobs, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatedBy, foreign.ID) {
				local.R.CreatedByUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByRebalanceJobs = append(foreign.R.CreatedByRebalanceJobs, local)
				break
			}
		}
	}

	return nil
}

// LoadJobRebalanceEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (rebalanceJobL) LoadJobRebalanceEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRebalanceJob interface{}, mods queries.Applicator) error {
	var slice []*RebalanceJob
	var object *RebalanceJob

	if singular {
		var ok bool
		object, ok = maybeRebalanceJob.(*RebalanceJob)
		if !ok {
			object = new(RebalanceJob)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeRebalanceJob))
			}
		}
	} else {
		s, ok := maybeRebalanceJob.(*[]*RebalanceJob)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeRebalanceJob)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeRebalanceJob))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &rebalanceJobR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &rebalanceJobR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`rebalance_events`),
		qm.WhereIn(`rebalance_events.job_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load rebalance_events")
	}

	var resultSlice []*RebalanceEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice rebalance_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on rebalance_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for rebalance_events")
	}

	if len(rebalanceEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.JobRebalanceEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &rebalanceEventR{}
			}
			foreign.R.Job = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.JobID) {
				local.R.JobRebalanceEvents = append(local.R.JobRebalanceEvents, foreign)
				if foreign.R == nil {
					foreign.R = &rebalanceEventR{}
				}
				foreign.R.Job = local
				break
			}
		}
	}

	return nil
}

// SetBoard of the rebalanceJob to the related item.
// Sets o.R.Board to related.
// Adds o to related.R.RebalanceJobs.
func (o *RebalanceJob) SetBoard(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Board) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_jobs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"board_id"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceJobPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BoardID, related.ID)
	if o.R == nil {
		o.R = &rebalanceJobR{
			Board: related,
		}
	} else {
		o.R.Board = related
	}

	if related.R == nil {
		related.R = &boardR{
			RebalanceJobs: RebalanceJobSlice{o},
		}
	} else {
		related.R.RebalanceJobs = append(related.R.RebalanceJobs, o)
	}

	return nil
}

// RemoveBoard relationship.
// Sets o.R.Board to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceJob) RemoveBoard(ctx context.Context, exec boil.ContextExecutor, related *Board) error {
	var err error

	queries.SetScanner(&o.BoardID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("board_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Board = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RebalanceJobs {
		if queries.Equal(o.BoardID, ri.BoardID) {
			continue
		}

		ln := len(related.R.RebalanceJobs)
		if ln > 1 && i < ln-1 {
			related.R.RebalanceJobs[i] = related.R.RebalanceJobs[ln-1]
		}
		related.R.RebalanceJobs = related.R.RebalanceJobs[:ln-1]
		break
	}
	return nil
}

// SetList of the rebalanceJob to the related item.
// Sets o.R.List to related.
// Adds o to related.R.RebalanceJobs.
func (o *RebalanceJob) SetList(ctx context.Context, exec boil.ContextExecutor, insert bool, related *List) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_jobs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"list_id"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceJobPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ListID, related.ID)
	if o.R == nil {
		o.R = &rebalanceJobR{
			List: related,
		}
	} else {
		o.R.List = related
	}

	if related.R == nil {
		related.R = &listR{
			RebalanceJobs: RebalanceJobSlice{o},
		}
	} else {
		related.R.RebalanceJobs = append(related.R.RebalanceJobs, o)
	}

	return nil
}

// RemoveList relationship.
// Sets o.R.List to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceJob) RemoveList(ctx context.Context, exec boil.ContextExecutor, related *List) error {
	var err error

	queries.SetScanner(&o.ListID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("list_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.List = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RebalanceJobs {
		if queries.Equal(o.ListID, ri.ListID) {
			continue
		}

		ln := len(related.R.RebalanceJobs)
		if ln > 1 && i < ln-1 {
			related.R.RebalanceJobs[i] = related.R.RebalanceJobs[ln-1]
		}
		related.R.RebalanceJobs = related.R.RebalanceJobs[:ln-1]
		break
	}
	return nil
}

// SetCreatedByUser of the rebalanceJob to the related item.
// Sets o.R.CreatedByUser to related.
// Adds o to related.R.CreatedByRebalanceJobs.
func (o *RebalanceJob) SetCreatedByUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"rebalance_jobs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by"}),
		strmangle.WhereClause("\"", "\"", 2, rebalanceJobPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatedBy, related.ID)
	if o.R == nil {
		o.R = &rebalanceJobR{
			CreatedByUser: related,
		}
	} else {
		o.R.CreatedByUser = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByRebalanceJobs: RebalanceJobSlice{o},
		}
	} else {
		related.R.CreatedByRebalanceJobs = append(related.R.CreatedByRebalanceJobs, o)
	}

	return nil
}

// RemoveCreatedByUser relationship.
// Sets o.R.CreatedByUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *RebalanceJob) RemoveCreatedByUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.CreatedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("created_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CreatedByUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatedByRebalanceJobs {
		if queries.Equal(o.CreatedBy, ri.CreatedBy) {
			continue
		}

		ln := len(related.R.CreatedByRebalanceJobs)
		if ln > 1 && i < ln-1 {
			related.R.CreatedByRebalanceJobs[i] = related.R.CreatedByRebalanceJobs[ln-1]
		}
		related.R.CreatedByRebalanceJobs = related.R.CreatedByRebalanceJobs[:ln-1]
		break
	}
	return nil
}

// AddJobRebalanceEvents adds the given related objects to the existing relationships
// of the rebalance_job, optionally inserting them as new records.
// Appends related to o.R.JobRebalanceEvents.
// Sets related.R.Job appropriately.
func (o *RebalanceJob) AddJobRebalanceEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RebalanceEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.JobID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"rebalance_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"job_id"}),
				strmangle.WhereClause("\"", "\"", 2, rebalanceEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.JobID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &rebalanceJobR{
			JobRebalanceEvents: related,
		}
	} else {
		o.R.JobRebalanceEvents = append(o.R.JobRebalanceEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &rebalanceEventR{
				Job: o,
			}
		} else {
			rel.R.Job = o
		}
	}
	return nil
}

// SetJobRebalanceEvents removes all previously related items of the
// rebalance_job replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Job's JobRebalanceEvents accordingly.
// Replaces o.R.JobRebalanceEvents with related.
// Sets related.R.Job's JobRebalanceEvents accordingly.
func (o *RebalanceJob) SetJobRebalanceEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RebalanceEvent) error {
	query := "update \"rebalance_events\" set \"job_id\" = null where \"job_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.JobRebalanceEvents {
			queries.SetScanner(&rel.JobID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Job = nil
		}
		o.R.JobRebalanceEvents = nil
	}

	return o.AddJobRebalanceEvents(ctx, exec, insert, related...)
}

// RemoveJobRebalanceEvents relationships from objects passed in.
// Removes related items from R.JobRebalanceEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.Job.
func (o *RebalanceJob) RemoveJobRebalanceEvents(ctx context.Context, exec boil.ContextExecutor, related ...*RebalanceEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.JobID, nil)
		if rel.R != nil {
			rel.R.Job = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("job_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.JobRebalanceEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.JobRebalanceEvents)
			if ln > 1 && i < ln-1 {
				o.R.JobRebalanceEvents[i] = o.R.JobRebalanceEvents[ln-1]
			}
			o.R.JobRebalanceEvents = o.R.JobRebalanceEvents[:ln-1]
			break
		}
	}

	return nil
}

// RebalanceJobs retrieves all the records using an executor.
func RebalanceJobs(mods ...qm.QueryMod) rebalanceJobQuery {
	mods = append(mods, qm.From("\"rebalance_jobs\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"rebalance_jobs\".*"})
	}

	return rebalanceJobQuery{q}
}

// FindRebalanceJob retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindRebalanceJob(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*RebalanceJob, error) {
	rebalanceJobObj := &RebalanceJob{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"rebalance_jobs\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, rebalanceJobObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from rebalance_jobs")
	}

	if err = rebalanceJobObj.doAfterSelectHooks(ctx, exec); err != nil {
		return rebalanceJobObj, err
	}

	return rebalanceJobObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *RebalanceJob) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no rebalance_jobs provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rebalanceJobColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	rebalanceJobInsertCacheMut.RLock()
	cache, cached := rebalanceJobInsertCache[key]
	rebalanceJobInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			rebalanceJobAllColumns,
			rebalanceJobColumnsWithDefault,
			rebalanceJobColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"rebalance_jobs\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"rebalance_jobs\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into rebalance_jobs")
	}

	if !cached {
		rebalanceJobInsertCacheMut.Lock()
		rebalanceJobInsertCache[key] = cache
		rebalanceJobInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the RebalanceJob.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *RebalanceJob) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	rebalanceJobUpdateCacheMut.RLock()
	cache, cached := rebalanceJobUpdateCache[key]
	rebalanceJobUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			rebalanceJobAllColumns,
			rebalanceJobPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update rebalance_jobs, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"rebalance_jobs\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, rebalanceJobPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, append(wl, rebalanceJobPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update rebalance_jobs row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for rebalance_jobs")
	}

	if !cached {
		rebalanceJobUpdateCacheMut.Lock()
		rebalanceJobUpdateCache[key] = cache
		rebalanceJobUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q rebalanceJobQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for rebalance_jobs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for rebalance_jobs")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o RebalanceJobSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceJobPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"rebalance_jobs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, rebalanceJobPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in rebalanceJob slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all rebalanceJob")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *RebalanceJob) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no rebalance_jobs provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rebalanceJobColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	rebalanceJobUpsertCacheMut.RLock()
	cache, cached := rebalanceJobUpsertCache[key]
	rebalanceJobUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			rebalanceJobAllColumns,
			rebalanceJobColumnsWithDefault,
			rebalanceJobColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			rebalanceJobAllColumns,
			rebalanceJobPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert rebalance_jobs, could not build update column list")
		}

		ret := strmangle.SetComplement(rebalanceJobAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(rebalanceJobPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert rebalance_jobs, could not build conflict column list")
			}

			conflict = make([]string, len(rebalanceJobPrimaryKeyColumns))
			copy(conflict, rebalanceJobPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"rebalance_jobs\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(rebalanceJobType, rebalanceJobMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert rebalance_jobs")
	}

	if !cached {
		rebalanceJobUpsertCacheMut.Lock()
		rebalanceJobUpsertCache[key] = cache
		rebalanceJobUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single RebalanceJob record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *RebalanceJob) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no RebalanceJob provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), rebalanceJobPrimaryKeyMapping)
	sql := "DELETE FROM \"rebalance_jobs\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from rebalance_jobs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for rebalance_jobs")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q rebalanceJobQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no rebalanceJobQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from rebalance_jobs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for rebalance_jobs")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o RebalanceJobSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(rebalanceJobBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceJobPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"rebalance_jobs\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, rebalanceJobPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from rebalanceJob slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for rebalance_jobs")
	}

	if len(rebalanceJobAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *RebalanceJob) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindRebalanceJob(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RebalanceJobSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := RebalanceJobSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rebalanceJobPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"rebalance_jobs\".* FROM \"rebalance_jobs\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, rebalanceJobPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in RebalanceJobSlice")
	}

	*o = slice

	return nil
}

// RebalanceJobExists checks if the RebalanceJob row exists.
func RebalanceJobExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"rebalance_jobs\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if rebalance_jobs exists")
	}

	return exists, nil
}

// Exists checks if the RebalanceJob row exists.
func (o *RebalanceJob) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return RebalanceJobExists(ctx, exec, o.ID)
}
