// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Card is an object representing the database table.
type Card struct {
	ID          string        `boil:"id" json:"id" toml:"id" yaml:"id"`
	ListID      string        `boil:"list_id" json:"list_id" toml:"list_id" yaml:"list_id"`
	Name        string        `boil:"name" json:"name" toml:"name" yaml:"name"`
	Description null.String   `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	Position    types.Decimal `boil:"position" json:"position" toml:"position" yaml:"position"`
	DueDate     null.Time     `boil:"due_date" json:"due_date,omitempty" toml:"due_date" yaml:"due_date,omitempty"`
	Priority    CardPriority  `boil:"priority" json:"priority" toml:"priority" yaml:"priority"`
	Labels      null.JSON     `boil:"labels" json:"labels,omitempty" toml:"labels" yaml:"labels,omitempty"`
	IsArchived  bool          `boil:"is_archived" json:"is_archived" toml:"is_archived" yaml:"is_archived"`
	CreatedAt   time.Time     `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt   time.Time     `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt   null.Time     `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	CreatedBy   null.String   `boil:"created_by" json:"created_by,omitempty" toml:"created_by" yaml:"created_by,omitempty"`
	// User ID of the person assigned to this card
	AssignedTo null.String `boil:"assigned_to" json:"assigned_to,omitempty" toml:"assigned_to" yaml:"assigned_to,omitempty"`
	// JSON array of uploaded file UUIDs
	Attachments null.JSON `boil:"attachments" json:"attachments,omitempty" toml:"attachments" yaml:"attachments,omitempty"`
	// Estimated time to complete the card in hours
	EstimatedHours types.NullDecimal `boil:"estimated_hours" json:"estimated_hours,omitempty" toml:"estimated_hours" yaml:"estimated_hours,omitempty"`
	// Actual time spent on the card in hours
	ActualHours types.NullDecimal `boil:"actual_hours" json:"actual_hours,omitempty" toml:"actual_hours" yaml:"actual_hours,omitempty"`
	// When work on this card should start
	StartDate null.Time `boil:"start_date" json:"start_date,omitempty" toml:"start_date" yaml:"start_date,omitempty"`
	// When the card was actually completed
	CompletionDate null.Time `boil:"completion_date" json:"completion_date,omitempty" toml:"completion_date" yaml:"completion_date,omitempty"`
	// Array of text tags for flexible categorization
	Tags types.StringArray `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	// JSON array of checklist items with completion status
	Checklist null.JSON `boil:"checklist" json:"checklist,omitempty" toml:"checklist" yaml:"checklist,omitempty"`
	// Timestamp of last activity on this card
	LastActivityAt null.Time `boil:"last_activity_at" json:"last_activity_at,omitempty" toml:"last_activity_at" yaml:"last_activity_at,omitempty"`
	// User ID who last modified this card
	UpdatedBy null.String `boil:"updated_by" json:"updated_by,omitempty" toml:"updated_by" yaml:"updated_by,omitempty"`
	// Short, memorable identifier for the card (e.g., PROJ-123, BUG-001)
	Alias null.String `boil:"alias" json:"alias,omitempty" toml:"alias" yaml:"alias,omitempty"`

	R *cardR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cardL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CardColumns = struct {
	ID             string
	ListID         string
	Name           string
	Description    string
	Position       string
	DueDate        string
	Priority       string
	Labels         string
	IsArchived     string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	CreatedBy      string
	AssignedTo     string
	Attachments    string
	EstimatedHours string
	ActualHours    string
	StartDate      string
	CompletionDate string
	Tags           string
	Checklist      string
	LastActivityAt string
	UpdatedBy      string
	Alias          string
}{
	ID:             "id",
	ListID:         "list_id",
	Name:           "name",
	Description:    "description",
	Position:       "position",
	DueDate:        "due_date",
	Priority:       "priority",
	Labels:         "labels",
	IsArchived:     "is_archived",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	CreatedBy:      "created_by",
	AssignedTo:     "assigned_to",
	Attachments:    "attachments",
	EstimatedHours: "estimated_hours",
	ActualHours:    "actual_hours",
	StartDate:      "start_date",
	CompletionDate: "completion_date",
	Tags:           "tags",
	Checklist:      "checklist",
	LastActivityAt: "last_activity_at",
	UpdatedBy:      "updated_by",
	Alias:          "alias",
}

var CardTableColumns = struct {
	ID             string
	ListID         string
	Name           string
	Description    string
	Position       string
	DueDate        string
	Priority       string
	Labels         string
	IsArchived     string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	CreatedBy      string
	AssignedTo     string
	Attachments    string
	EstimatedHours string
	ActualHours    string
	StartDate      string
	CompletionDate string
	Tags           string
	Checklist      string
	LastActivityAt string
	UpdatedBy      string
	Alias          string
}{
	ID:             "cards.id",
	ListID:         "cards.list_id",
	Name:           "cards.name",
	Description:    "cards.description",
	Position:       "cards.position",
	DueDate:        "cards.due_date",
	Priority:       "cards.priority",
	Labels:         "cards.labels",
	IsArchived:     "cards.is_archived",
	CreatedAt:      "cards.created_at",
	UpdatedAt:      "cards.updated_at",
	DeletedAt:      "cards.deleted_at",
	CreatedBy:      "cards.created_by",
	AssignedTo:     "cards.assigned_to",
	Attachments:    "cards.attachments",
	EstimatedHours: "cards.estimated_hours",
	ActualHours:    "cards.actual_hours",
	StartDate:      "cards.start_date",
	CompletionDate: "cards.completion_date",
	Tags:           "cards.tags",
	Checklist:      "cards.checklist",
	LastActivityAt: "cards.last_activity_at",
	UpdatedBy:      "cards.updated_by",
	Alias:          "cards.alias",
}

// Generated where

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperCardPriority struct{ field string }

func (w whereHelperCardPriority) EQ(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperCardPriority) NEQ(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperCardPriority) LT(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperCardPriority) LTE(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperCardPriority) GT(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperCardPriority) GTE(x CardPriority) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperCardPriority) IN(slice []CardPriority) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperCardPriority) NIN(slice []CardPriority) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var CardWhere = struct {
	ID             whereHelperstring
	ListID         whereHelperstring
	Name           whereHelperstring
	Description    whereHelpernull_String
	Position       whereHelpertypes_Decimal
	DueDate        whereHelpernull_Time
	Priority       whereHelperCardPriority
	Labels         whereHelpernull_JSON
	IsArchived     whereHelperbool
	CreatedAt      whereHelpertime_Time
	UpdatedAt      whereHelpertime_Time
	DeletedAt      whereHelpernull_Time
	CreatedBy      whereHelpernull_String
	AssignedTo     whereHelpernull_String
	Attachments    whereHelpernull_JSON
	EstimatedHours whereHelpertypes_NullDecimal
	ActualHours    whereHelpertypes_NullDecimal
	StartDate      whereHelpernull_Time
	CompletionDate whereHelpernull_Time
	Tags           whereHelpertypes_StringArray
	Checklist      whereHelpernull_JSON
	LastActivityAt whereHelpernull_Time
	UpdatedBy      whereHelpernull_String
	Alias          whereHelpernull_String
}{
	ID:             whereHelperstring{field: "\"cards\".\"id\""},
	ListID:         whereHelperstring{field: "\"cards\".\"list_id\""},
	Name:           whereHelperstring{field: "\"cards\".\"name\""},
	Description:    whereHelpernull_String{field: "\"cards\".\"description\""},
	Position:       whereHelpertypes_Decimal{field: "\"cards\".\"position\""},
	DueDate:        whereHelpernull_Time{field: "\"cards\".\"due_date\""},
	Priority:       whereHelperCardPriority{field: "\"cards\".\"priority\""},
	Labels:         whereHelpernull_JSON{field: "\"cards\".\"labels\""},
	IsArchived:     whereHelperbool{field: "\"cards\".\"is_archived\""},
	CreatedAt:      whereHelpertime_Time{field: "\"cards\".\"created_at\""},
	UpdatedAt:      whereHelpertime_Time{field: "\"cards\".\"updated_at\""},
	DeletedAt:      whereHelpernull_Time{field: "\"cards\".\"deleted_at\""},
	CreatedBy:      whereHelpernull_String{field: "\"cards\".\"created_by\""},
	AssignedTo:     whereHelpernull_String{field: "\"cards\".\"assigned_to\""},
	Attachments:    whereHelpernull_JSON{field: "\"cards\".\"attachments\""},
	EstimatedHours: whereHelpertypes_NullDecimal{field: "\"cards\".\"estimated_hours\""},
	ActualHours:    whereHelpertypes_NullDecimal{field: "\"cards\".\"actual_hours\""},
	StartDate:      whereHelpernull_Time{field: "\"cards\".\"start_date\""},
	CompletionDate: whereHelpernull_Time{field: "\"cards\".\"completion_date\""},
	Tags:           whereHelpertypes_StringArray{field: "\"cards\".\"tags\""},
	Checklist:      whereHelpernull_JSON{field: "\"cards\".\"checklist\""},
	LastActivityAt: whereHelpernull_Time{field: "\"cards\".\"last_activity_at\""},
	UpdatedBy:      whereHelpernull_String{field: "\"cards\".\"updated_by\""},
	Alias:          whereHelpernull_String{field: "\"cards\".\"alias\""},
}

// CardRels is where relationship names are stored.
var CardRels = struct {
	AssignedToUser string
	CreatedByUser  string
	UpdatedByUser  string
	List           string
	CardActivities string
	Comments       string
}{
	AssignedToUser: "AssignedToUser",
	CreatedByUser:  "CreatedByUser",
	UpdatedByUser:  "UpdatedByUser",
	List:           "List",
	CardActivities: "CardActivities",
	Comments:       "Comments",
}

// cardR is where relationships are stored.
type cardR struct {
	AssignedToUser *User             `boil:"AssignedToUser" json:"AssignedToUser" toml:"AssignedToUser" yaml:"AssignedToUser"`
	CreatedByUser  *User             `boil:"CreatedByUser" json:"CreatedByUser" toml:"CreatedByUser" yaml:"CreatedByUser"`
	UpdatedByUser  *User             `boil:"UpdatedByUser" json:"UpdatedByUser" toml:"UpdatedByUser" yaml:"UpdatedByUser"`
	List           *List             `boil:"List" json:"List" toml:"List" yaml:"List"`
	CardActivities CardActivitySlice `boil:"CardActivities" json:"CardActivities" toml:"CardActivities" yaml:"CardActivities"`
	Comments       CommentSlice      `boil:"Comments" json:"Comments" toml:"Comments" yaml:"Comments"`
}

// NewStruct creates a new relationship struct
func (*cardR) NewStruct() *cardR {
	return &cardR{}
}

func (o *Card) GetAssignedToUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetAssignedToUser()
}

func (r *cardR) GetAssignedToUser() *User {
	if r == nil {
		return nil
	}

	return r.AssignedToUser
}

func (o *Card) GetCreatedByUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByUser()
}

func (r *cardR) GetCreatedByUser() *User {
	if r == nil {
		return nil
	}

	return r.CreatedByUser
}

func (o *Card) GetUpdatedByUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUpdatedByUser()
}

func (r *cardR) GetUpdatedByUser() *User {
	if r == nil {
		return nil
	}

	return r.UpdatedByUser
}

func (o *Card) GetList() *List {
	if o == nil {
		return nil
	}

	return o.R.GetList()
}

func (r *cardR) GetList() *List {
	if r == nil {
		return nil
	}

	return r.List
}

func (o *Card) GetCardActivities() CardActivitySlice {
	if o == nil {
		return nil
	}

	return o.R.GetCardActivities()
}

func (r *cardR) GetCardActivities() CardActivitySlice {
	if r == nil {
		return nil
	}

	return r.CardActivities
}

func (o *Card) GetComments() CommentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetComments()
}

func (r *cardR) GetComments() CommentSlice {
	if r == nil {
		return nil
	}

	return r.Comments
}

// cardL is where Load methods for each relationship are stored.
type cardL struct{}

var (
	cardAllColumns            = []string{"id", "list_id", "name", "description", "position", "due_date", "priority", "labels", "is_archived", "created_at", "updated_at", "deleted_at", "created_by", "assigned_to", "attachments", "estimated_hours", "actual_hours", "start_date", "completion_date", "tags", "checklist", "last_activity_at", "updated_by", "alias"}
	cardColumnsWithoutDefault = []string{"list_id", "name", "position"}
	cardColumnsWithDefault    = []string{"id", "description", "due_date", "priority", "labels", "is_archived", "created_at", "updated_at", "deleted_at", "created_by", "assigned_to", "attachments", "estimated_hours", "actual_hours", "start_date", "completion_date", "tags", "checklist", "last_activity_at", "updated_by", "alias"}
	cardPrimaryKeyColumns     = []string{"id"}
	cardGeneratedColumns      = []string{}
)

type (
	// CardSlice is an alias for a slice of pointers to Card.
	// This should almost always be used instead of []Card.
	CardSlice []*Card
	// CardHook is the signature for custom Card hook methods
	CardHook func(context.Context, boil.ContextExecutor, *Card) error

	cardQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cardType                 = reflect.TypeOf(&Card{})
	cardMapping              = queries.MakeStructMapping(cardType)
	cardPrimaryKeyMapping, _ = queries.BindMapping(cardType, cardMapping, cardPrimaryKeyColumns)
	cardInsertCacheMut       sync.RWMutex
	cardInsertCache          = make(map[string]insertCache)
	cardUpdateCacheMut       sync.RWMutex
	cardUpdateCache          = make(map[string]updateCache)
	cardUpsertCacheMut       sync.RWMutex
	cardUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cardAfterSelectMu sync.Mutex
var cardAfterSelectHooks []CardHook

var cardBeforeInsertMu sync.Mutex
var cardBeforeInsertHooks []CardHook
var cardAfterInsertMu sync.Mutex
var cardAfterInsertHooks []CardHook

var cardBeforeUpdateMu sync.Mutex
var cardBeforeUpdateHooks []CardHook
var cardAfterUpdateMu sync.Mutex
var cardAfterUpdateHooks []CardHook

var cardBeforeDeleteMu sync.Mutex
var cardBeforeDeleteHooks []CardHook
var cardAfterDeleteMu sync.Mutex
var cardAfterDeleteHooks []CardHook

var cardBeforeUpsertMu sync.Mutex
var cardBeforeUpsertHooks []CardHook
var cardAfterUpsertMu sync.Mutex
var cardAfterUpsertHooks []CardHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Card) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Card) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Card) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Card) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Card) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Card) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Card) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Card) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Card) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cardAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCardHook registers your hook function for all future operations.
func AddCardHook(hookPoint boil.HookPoint, cardHook CardHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		cardAfterSelectMu.Lock()
		cardAfterSelectHooks = append(cardAfterSelectHooks, cardHook)
		cardAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		cardBeforeInsertMu.Lock()
		cardBeforeInsertHooks = append(cardBeforeInsertHooks, cardHook)
		cardBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		cardAfterInsertMu.Lock()
		cardAfterInsertHooks = append(cardAfterInsertHooks, cardHook)
		cardAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		cardBeforeUpdateMu.Lock()
		cardBeforeUpdateHooks = append(cardBeforeUpdateHooks, cardHook)
		cardBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		cardAfterUpdateMu.Lock()
		cardAfterUpdateHooks = append(cardAfterUpdateHooks, cardHook)
		cardAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		cardBeforeDeleteMu.Lock()
		cardBeforeDeleteHooks = append(cardBeforeDeleteHooks, cardHook)
		cardBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		cardAfterDeleteMu.Lock()
		cardAfterDeleteHooks = append(cardAfterDeleteHooks, cardHook)
		cardAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		cardBeforeUpsertMu.Lock()
		cardBeforeUpsertHooks = append(cardBeforeUpsertHooks, cardHook)
		cardBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		cardAfterUpsertMu.Lock()
		cardAfterUpsertHooks = append(cardAfterUpsertHooks, cardHook)
		cardAfterUpsertMu.Unlock()
	}
}

// One returns a single card record from the query.
func (q cardQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Card, error) {
	o := &Card{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for cards")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Card records from the query.
func (q cardQuery) All(ctx context.Context, exec boil.ContextExecutor) (CardSlice, error) {
	var o []*Card

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to Card slice")
	}

	if len(cardAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Card records in the query.
func (q cardQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count cards rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cardQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if cards exists")
	}

	return count > 0, nil
}

// AssignedToUser pointed to by the foreign key.
func (o *Card) AssignedToUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AssignedTo),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// CreatedByUser pointed to by the foreign key.
func (o *Card) CreatedByUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedBy),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// UpdatedByUser pointed to by the foreign key.
func (o *Card) UpdatedByUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UpdatedBy),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// List pointed to by the foreign key.
func (o *Card) List(mods ...qm.QueryMod) listQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ListID),
	}

	queryMods = append(queryMods, mods...)

	return Lists(queryMods...)
}

// CardActivities retrieves all the card_activity's CardActivities with an executor.
func (o *Card) CardActivities(mods ...qm.QueryMod) cardActivityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"card_activities\".\"card_id\"=?", o.ID),
	)

	return CardActivities(queryMods...)
}

// Comments retrieves all the comment's Comments with an executor.
func (o *Card) Comments(mods ...qm.QueryMod) commentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"comments\".\"card_id\"=?", o.ID),
	)

	return Comments(queryMods...)
}

// LoadAssignedToUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (cardL) LoadAssignedToUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		if !queries.IsNil(object.AssignedTo) {
			args[object.AssignedTo] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}

			if !queries.IsNil(obj.AssignedTo) {
				args[obj.AssignedTo] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`users.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AssignedToUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.AssignedToCards = append(foreign.R.AssignedToCards, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AssignedTo, foreign.ID) {
				local.R.AssignedToUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.AssignedToCards = append(foreign.R.AssignedToCards, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedByUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (cardL) LoadCreatedByUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		if !queries.IsNil(object.CreatedBy) {
			args[object.CreatedBy] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}

			if !queries.IsNil(obj.CreatedBy) {
				args[obj.CreatedBy] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`users.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedByUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByCards = append(foreign.R.CreatedByCards, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatedBy, foreign.ID) {
				local.R.CreatedByUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByCards = append(foreign.R.CreatedByCards, local)
				break
			}
		}
	}

	return nil
}

// LoadUpdatedByUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (cardL) LoadUpdatedByUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		if !queries.IsNil(object.UpdatedBy) {
			args[object.UpdatedBy] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}

			if !queries.IsNil(obj.UpdatedBy) {
				args[obj.UpdatedBy] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`users.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UpdatedByUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.UpdatedByCards = append(foreign.R.UpdatedByCards, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.UpdatedBy, foreign.ID) {
				local.R.UpdatedByUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.UpdatedByCards = append(foreign.R.UpdatedByCards, local)
				break
			}
		}
	}

	return nil
}

// LoadList allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (cardL) LoadList(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		args[object.ListID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}

			args[obj.ListID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`lists`),
		qm.WhereIn(`lists.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`lists.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load List")
	}

	var resultSlice []*List
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice List")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for lists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lists")
	}

	if len(listAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.List = foreign
		if foreign.R == nil {
			foreign.R = &listR{}
		}
		foreign.R.Cards = append(foreign.R.Cards, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ListID == foreign.ID {
				local.R.List = foreign
				if foreign.R == nil {
					foreign.R = &listR{}
				}
				foreign.R.Cards = append(foreign.R.Cards, local)
				break
			}
		}
	}

	return nil
}

// LoadCardActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (cardL) LoadCardActivities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`card_activities`),
		qm.WhereIn(`card_activities.card_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`card_activities.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load card_activities")
	}

	var resultSlice []*CardActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice card_activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on card_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for card_activities")
	}

	if len(cardActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CardActivities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cardActivityR{}
			}
			foreign.R.Card = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CardID {
				local.R.CardActivities = append(local.R.CardActivities, foreign)
				if foreign.R == nil {
					foreign.R = &cardActivityR{}
				}
				foreign.R.Card = local
				break
			}
		}
	}

	return nil
}

// LoadComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (cardL) LoadComments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCard interface{}, mods queries.Applicator) error {
	var slice []*Card
	var object *Card

	if singular {
		var ok bool
		object, ok = maybeCard.(*Card)
		if !ok {
			object = new(Card)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCard))
			}
		}
	} else {
		s, ok := maybeCard.(*[]*Card)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCard)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCard))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`comments`),
		qm.WhereIn(`comments.card_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`comments.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comments")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comments")
	}

	if len(commentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Comments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentR{}
			}
			foreign.R.Card = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CardID {
				local.R.Comments = append(local.R.Comments, foreign)
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.Card = local
				break
			}
		}
	}

	return nil
}

// SetAssignedToUser of the card to the related item.
// Sets o.R.AssignedToUser to related.
// Adds o to related.R.AssignedToCards.
func (o *Card) SetAssignedToUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"cards\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"assigned_to"}),
		strmangle.WhereClause("\"", "\"", 2, cardPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AssignedTo, related.ID)
	if o.R == nil {
		o.R = &cardR{
			AssignedToUser: related,
		}
	} else {
		o.R.AssignedToUser = related
	}

	if related.R == nil {
		related.R = &userR{
			AssignedToCards: CardSlice{o},
		}
	} else {
		related.R.AssignedToCards = append(related.R.AssignedToCards, o)
	}

	return nil
}

// RemoveAssignedToUser relationship.
// Sets o.R.AssignedToUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Card) RemoveAssignedToUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.AssignedTo, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("assigned_to")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.AssignedToUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AssignedToCards {
		if queries.Equal(o.AssignedTo, ri.AssignedTo) {
			continue
		}

		ln := len(related.R.AssignedToCards)
		if ln > 1 && i < ln-1 {
			related.R.AssignedToCards[i] = related.R.AssignedToCards[ln-1]
		}
		related.R.AssignedToCards = related.R.AssignedToCards[:ln-1]
		break
	}
	return nil
}

// SetCreatedByUser of the card to the related item.
// Sets o.R.CreatedByUser to related.
// Adds o to related.R.CreatedByCards.
func (o *Card) SetCreatedByUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"cards\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by"}),
		strmangle.WhereClause("\"", "\"", 2, cardPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatedBy, related.ID)
	if o.R == nil {
		o.R = &cardR{
			CreatedByUser: related,
		}
	} else {
		o.R.CreatedByUser = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByCards: CardSlice{o},
		}
	} else {
		related.R.CreatedByCards = append(related.R.CreatedByCards, o)
	}

	return nil
}

// RemoveCreatedByUser relationship.
// Sets o.R.CreatedByUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Card) RemoveCreatedByUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.CreatedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("created_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CreatedByUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatedByCards {
		if queries.Equal(o.CreatedBy, ri.CreatedBy) {
			continue
		}

		ln := len(related.R.CreatedByCards)
		if ln > 1 && i < ln-1 {
			related.R.CreatedByCards[i] = related.R.CreatedByCards[ln-1]
		}
		related.R.CreatedByCards = related.R.CreatedByCards[:ln-1]
		break
	}
	return nil
}

// SetUpdatedByUser of the card to the related item.
// Sets o.R.UpdatedByUser to related.
// Adds o to related.R.UpdatedByCards.
func (o *Card) SetUpdatedByUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"cards\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"updated_by"}),
		strmangle.WhereClause("\"", "\"", 2, cardPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.UpdatedBy, related.ID)
	if o.R == nil {
		o.R = &cardR{
			UpdatedByUser: related,
		}
	} else {
		o.R.UpdatedByUser = related
	}

	if related.R == nil {
		related.R = &userR{
			UpdatedByCards: CardSlice{o},
		}
	} else {
		related.R.UpdatedByCards = append(related.R.UpdatedByCards, o)
	}

	return nil
}

// RemoveUpdatedByUser relationship.
// Sets o.R.UpdatedByUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Card) RemoveUpdatedByUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.UpdatedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("updated_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.UpdatedByUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.UpdatedByCards {
		if queries.Equal(o.UpdatedBy, ri.UpdatedBy) {
			continue
		}

		ln := len(related.R.UpdatedByCards)
		if ln > 1 && i < ln-1 {
			related.R.UpdatedByCards[i] = related.R.UpdatedByCards[ln-1]
		}
		related.R.UpdatedByCards = related.R.UpdatedByCards[:ln-1]
		break
	}
	return nil
}

// SetList of the card to the related item.
// Sets o.R.List to related.
// Adds o to related.R.Cards.
func (o *Card) SetList(ctx context.Context, exec boil.ContextExecutor, insert bool, related *List) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"cards\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"list_id"}),
		strmangle.WhereClause("\"", "\"", 2, cardPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ListID = related.ID
	if o.R == nil {
		o.R = &cardR{
			List: related,
		}
	} else {
		o.R.List = related
	}

	if related.R == nil {
		related.R = &listR{
			Cards: CardSlice{o},
		}
	} else {
		related.R.Cards = append(related.R.Cards, o)
	}

	return nil
}

// AddCardActivities adds the given related objects to the existing relationships
// of the card, optionally inserting them as new records.
// Appends related to o.R.CardActivities.
// Sets related.R.Card appropriately.
func (o *Card) AddCardActivities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CardActivity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CardID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"card_activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"card_id"}),
				strmangle.WhereClause("\"", "\"", 2, cardActivityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CardID = o.ID
		}
	}

	if o.R == nil {
		o.R = &cardR{
			CardActivities: related,
		}
	} else {
		o.R.CardActivities = append(o.R.CardActivities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cardActivityR{
				Card: o,
			}
		} else {
			rel.R.Card = o
		}
	}
	return nil
}

// AddComments adds the given related objects to the existing relationships
// of the card, optionally inserting them as new records.
// Appends related to o.R.Comments.
// Sets related.R.Card appropriately.
func (o *Card) AddComments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Comment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CardID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"comments\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"card_id"}),
				strmangle.WhereClause("\"", "\"", 2, commentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CardID = o.ID
		}
	}

	if o.R == nil {
		o.R = &cardR{
			Comments: related,
		}
	} else {
		o.R.Comments = append(o.R.Comments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentR{
				Card: o,
			}
		} else {
			rel.R.Card = o
		}
	}
	return nil
}

// Cards retrieves all the records using an executor.
func Cards(mods ...qm.QueryMod) cardQuery {
	mods = append(mods, qm.From("\"cards\""), qmhelper.WhereIsNull("\"cards\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"cards\".*"})
	}

	return cardQuery{q}
}

// FindCard retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCard(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Card, error) {
	cardObj := &Card{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"cards\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cardObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from cards")
	}

	if err = cardObj.doAfterSelectHooks(ctx, exec); err != nil {
		return cardObj, err
	}

	return cardObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Card) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no cards provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cardColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cardInsertCacheMut.RLock()
	cache, cached := cardInsertCache[key]
	cardInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cardAllColumns,
			cardColumnsWithDefault,
			cardColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cardType, cardMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cardType, cardMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"cards\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"cards\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into cards")
	}

	if !cached {
		cardInsertCacheMut.Lock()
		cardInsertCache[key] = cache
		cardInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Card.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Card) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cardUpdateCacheMut.RLock()
	cache, cached := cardUpdateCache[key]
	cardUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cardAllColumns,
			cardPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update cards, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"cards\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, cardPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cardType, cardMapping, append(wl, cardPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update cards row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for cards")
	}

	if !cached {
		cardUpdateCacheMut.Lock()
		cardUpdateCache[key] = cache
		cardUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cardQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for cards")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for cards")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CardSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"cards\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, cardPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in card slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all card")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Card) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("dbmodels: no cards provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cardColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cardUpsertCacheMut.RLock()
	cache, cached := cardUpsertCache[key]
	cardUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			cardAllColumns,
			cardColumnsWithDefault,
			cardColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			cardAllColumns,
			cardPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert cards, could not build update column list")
		}

		ret := strmangle.SetComplement(cardAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(cardPrimaryKeyColumns) == 0 {
				return errors.New("dbmodels: unable to upsert cards, could not build conflict column list")
			}

			conflict = make([]string, len(cardPrimaryKeyColumns))
			copy(conflict, cardPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"cards\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(cardType, cardMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cardType, cardMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert cards")
	}

	if !cached {
		cardUpsertCacheMut.Lock()
		cardUpsertCache[key] = cache
		cardUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Card record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Card) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no Card provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cardPrimaryKeyMapping)
		sql = "DELETE FROM \"cards\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"cards\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(cardType, cardMapping, append(wl, cardPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from cards")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for cards")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cardQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no cardQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from cards")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for cards")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CardSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cardBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"cards\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cardPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"cards\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, cardPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from card slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for cards")
	}

	if len(cardAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Card) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCard(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CardSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CardSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"cards\".* FROM \"cards\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cardPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in CardSlice")
	}

	*o = slice

	return nil
}

// CardExists checks if the Card row exists.
func CardExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"cards\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if cards exists")
	}

	return exists, nil
}

// Exists checks if the Card row exists.
func (o *Card) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CardExists(ctx, exec, o.ID)
}
